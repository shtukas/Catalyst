#!/Users/pascal/.rvm/rubies/ruby-2.5.1/bin/ruby

require 'fileutils'
# FileUtils.mkpath '/a/b/c'
# FileUtils.cp(src, dst)
# FileUtils.mv 'oldname', 'newname'
# FileUtils.rm(path_to_image)
# FileUtils.rm_rf('dir/to/remove')

# encoding: UTF-8

require_relative "InFlightControlSystem.rb"

def descriptionExended(item, nsize)
    if itemIsTopActiveItem(item["uuid"]) then
        "(#{"%6.3f" % item["position"]}) #{item["description"].ljust(nsize)} (#{"%6.2f" % (getItemLiveTimespan(item["uuid"]).to_f/3600)} hours)"
    else
        "(#{"%6.3f" % item["position"]}) #{item["description"].ljust(nsize)}"
    end
end

def itemDive(item)
    loop {
        puts JSON.pretty_generate(item)
        oxs = [ 
            "start", 
            "stop",
            "set description",
            "set position",
            "suspend temporarily",
            "destroy"
        ]
        ox = LucilleCore::selectEntityFromListOfEntitiesOrNull("ifcs", oxs)
        return if ox.nil?
        if ox == "start" then
            startItem(item["uuid"])
        end
        if ox == "stop" then
            stopItem(item["uuid"])
        end
        if ox == "set description" then
            item["description"] = LucilleCore::askQuestionAnswerAsString("description: ")
            saveItem(item)
        end
        if ox == "set position" then
            item["position"] = LucilleCore::askQuestionAnswerAsString("position: ").to_f
            saveItem(item)
        end
        if ox == "suspend temporarily" then
            timespanInHours = LucilleCore::askQuestionAnswerAsString("time in hours: ").to_f
            item["DoNotShowUntilUnixtime"] = Time.new.to_i + timespanInHours*3600
            saveItem(item)
        end
        if ox == "destroy" then
            uuid = item["uuid"]
            filepath = "#{itemsFolderpath()}/#{uuid}.json"
            FileUtils.rm(filepath)
        end
    }
end

loop {
    system('clear')
    puts getReportLine()
    puts ""

    itxs = []

    nsize = getItems()
            .reject{|item| item["uuid"] == waveuuid() }
            .map{|item| item["description"].size }
            .max

    itemsOrderedByPosition().each{|item|
        itxs << [ descriptionExended(item, nsize), lambda { itemDive(item) } ]
    }

    itxs << [ "-> apply recommended", lambda {
        nextaction = getNextAction()
        nextaction[1].call()
    }]

    status = LucilleCore::menuItemsWithLambdas(itxs)
    break if status.nil?
}




