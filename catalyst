#!/usr/bin/ruby

# encoding: UTF-8

require 'json'

require 'date'

require 'colorize'

require 'securerandom'
# SecureRandom.hex    #=> "eb693ec8252cd630102fd0d0fb7c3485"
# SecureRandom.hex(4) #=> "eb693123"
# SecureRandom.uuid   #=> "2d931510-d99f-494a-8c67-87feb05e1594"

require "/Galaxy/LucilleOS/Misc-Resources/Ruby-Libraries/LucilleCore.rb"

require 'fileutils'
# FileUtils.mkpath '/a/b/c'
# FileUtils.cp(src, dst)
# FileUtils.mv 'oldname', 'newname'
# FileUtils.rm(path_to_image)
# FileUtils.rm_rf('dir/to/remove')

require_relative "CatalystCore.rb"

require_relative "Wave-Emails.rb"

# ----------------------------------------------------------------------------

CATALYST_DROPOFF_FOLDERPATH = "/Galaxy/DataBank/Catalyst/Wave-DropOff"
NINJA_DROPOFF_FOLDERPATH = "/Galaxy/DataBank/Catalyst/Ninja-DropOff"
NINJA_ITEMS_REPOSITORY_FOLDERPATH = "/Galaxy/DataBank/Ninja/Items"

class DropOff
    # DropOff::collectWaveObjects()
    def self.collectWaveObjects()
        Dir.entries(CATALYST_DROPOFF_FOLDERPATH)
            .select{|filename| filename[0, 1] != '.' }
            .map{|filename| "#{CATALYST_DROPOFF_FOLDERPATH}/#{filename}" }
            .each{|sourcelocation|
                uuid = SecureRandom.hex(4)
                description = 
                    if sourcelocation[-4,4] == '.txt' and IO.read(sourcelocation).lines.to_a.size == 1 then
                        IO.read(sourcelocation).strip
                    else
                        File.basename(sourcelocation)
                    end
                schedule = WaveSchedules::makeScheduleObjectNew()
                folderpath = WaveTimelineUtils::timestring22ToFolderpath(LucilleCore::timeStringL22())
                FileUtils.mkpath folderpath
                File.open("#{folderpath}/catalyst-uuid", 'w') {|f| f.write(uuid) }
                File.open("#{folderpath}/catalyst-description.txt", 'w') {|f| f.write(description) }
                WaveTimelineUtils::writeScheduleToDisk(uuid,schedule)
                if File.file?(sourcelocation) then
                    FileUtils.cp(sourcelocation,folderpath)
                else
                    FileUtils.cp_r(sourcelocation,folderpath)
                end
                File.open("#{folderpath}/wave-target-filename.txt", 'w') {|f| f.write(File.basename(sourcelocation)) }
                LucilleCore::removeFileSystemLocation(sourcelocation)
            }
    end
    # DropOff::collectNinjaObjects()
    def self.collectNinjaObjects()
        Dir.entries(NINJA_DROPOFF_FOLDERPATH)
            .select{|filename| filename[0, 1] != '.' }
            .map{|filename| "#{NINJA_DROPOFF_FOLDERPATH}/#{filename}" }
            .each{|sourcelocation|
                folderpath = "#{NINJA_ITEMS_REPOSITORY_FOLDERPATH}/#{Time.new.strftime("%Y")}/#{Time.new.strftime("%Y%m")}/#{Time.new.strftime("%Y%m%d")}/#{Time.new.strftime("%Y%m%d-%H%M%S-%6N")}-ninja"
                FileUtils.mkpath(folderpath)
                if File.file?(sourcelocation) then
                    FileUtils.cp(sourcelocation,folderpath)
                else
                    FileUtils.cp_r(sourcelocation,folderpath)
                end
                LucilleCore::removeFileSystemLocation(sourcelocation)
            }
    end
end

def email_sync_on_schedule(verbose)
    if LucilleCore::trueNoMoreOftenThanNEverySeconds("29a504de-7985-493b-b809-332357bda3a7", 1200) then
        begin
            newEmailCount = GeneralEmailClient::syncEmailDataWithServer(JSON.parse(IO.read("/Galaxy/DataBank/Catalyst/Wave-Email-Config/guardian-relay.json")), verbose)
            if newEmailCount>0 then
                puts "Retrieved #{newEmailCount} new emails"
            end
            OperatorEmailDownloader::syncEmailDataWithServer(JSON.parse(IO.read("/Galaxy/DataBank/Catalyst/Wave-Email-Config/operator.json")), verbose)
            # We call again so that the clock restarts at the end of the process
            LucilleCore::trueNoMoreOftenThanNEverySecondsReset("29a504de-7985-493b-b809-332357bda3a7")
        rescue
        end
    end    
end

def screen_height()
    `/usr/bin/env tput lines`.to_i
end

def screen_width()
    `/usr/bin/env tput cols`.to_i
end

def vertical_space(announce)
    announce.lines.map{|line| (line.size/screen_width())+1 }.inject(0, :+)
end

def tokenIsInteger(token)
    token == token.to_i.to_s
end

def puts_object_shell_display(object, dislayobjects)
    
    dislayobjects = dislayobjects.clone

    # Here is the reason why the second argument was introduced
    # A first display is performed. 
    # You select number 8.
    # The list of objects is recomputed and the 8th (actually the 9th) one is selected.
    # There is no guaranty that the one selected was the one you were looking at since the objects
    # could have been reordered between the two computations.

    # Here:
    # If you select an ordinal, you get to apply it to the list you were looking at when you made that 
    # mental selection.

    requirements = $requirement_operator.getObjectRequirements(object['uuid']).join(", ")
    requirements = requirements.size>0 ? " ( #{requirements} )".green : ''

    puts "#{object['announce'].strip}#{requirements}"

    object['default-commands'] = [] if object['default-commands'].nil?

    puts [
        object['default-commands'].join(" ").green ,
        object['commands'].join(" ").red
    ].select{|s| s.size>0 }.join(" ; ").strip

    print "---> "

    expression = STDIN.gets().strip

    if expression.start_with?('insert') then
        description = expression[6,expression.size].strip
        uuid = SecureRandom.hex(4)
        schedule = WaveSchedules::makeScheduleObjectInteractivelyOrNull()
        folderpath = WaveTimelineUtils::timestring22ToFolderpath(LucilleCore::timeStringL22())
        FileUtils.mkpath folderpath
        File.open("#{folderpath}/catalyst-uuid", 'w') {|f| f.write(uuid) }
        File.open("#{folderpath}/catalyst-description.txt", 'w') {|f| f.write(description) }
        WaveTimelineUtils::writeScheduleToDisk(uuid, schedule)
        return
    end

    if expression.start_with?("search") then
        pattern = expression[6,expression.size].strip
        searchobjects = CatalystCore::objects()
            .select{|object| object['announce'].downcase.include?(pattern.downcase) }
        if searchobjects.size>0 then
            searchobject = LucilleCore::interactivelySelectEntityFromListOfEntitiesOrNull("object: ", searchobjects, lambda{ |item| item['announce'] })
            if searchobject then
                puts_object_shell_display(searchobject, dislayobjects)
            end
        end
        return
    end

    if expression.start_with?("requirement") then
        requirement = expression[11,expression.size].strip
        $requirement_operator.setRequirementOff(requirement)
        return
    end

    if expression.start_with?("on") then
        requirement = expression[2,expression.size].strip
        $requirement_operator.setRequirementOn(requirement)
        return
    end

    if expression.start_with?("off") then
        requirement = expression[3,expression.size].strip
        $requirement_operator.setRequirementOff(requirement)
        return
    end

    # ---------------------
    # default commands

    if expression.size==0 and object['default-commands'] then
        object['default-commands'].each{|command|
            if command.start_with?('shell:') then
                command = command[7,command.size].strip
                system(command)
            else
                object['command-interpreter'].call(object, command)
            end
        }
        return
    end

    # ---------------------
    # regular expression: optional integer and commands

    def expression_decomposition(expression, dislayobjects)
        dislayobjects = dislayobjects.clone
        tokens = 
            if expression.start_with?('+') then
                [expression]
            else
                expression.split(' ').map{|t| t.strip }
            end
        if tokenIsInteger(tokens[0]) then
            targetObject = dislayobjects.drop(tokens[0].to_i).first # overriding the current object with the targetted object
            tokens.shift
            [targetObject, tokens]
        else
            [nil, tokens]
        end
    end

    targetObject, tokens = expression_decomposition(expression, dislayobjects)

    if targetObject and tokens.size==0 then
        puts_object_shell_display(targetObject, dislayobjects)
    end

    if targetObject and tokens.size>0 then
        tokens.each{|command|
            targetObject['command-interpreter'].call(targetObject, command)
        }
    end    

    if targetObject.nil? and tokens.size==0 then
        # Nothing to do 
    end

    if targetObject.nil? and tokens.size>0 then
        tokens.each{|command|
            object['command-interpreter'].call(object, command)
        }        
    end
end

def puts_objects(objects, remaining_number_of_lines, indx)
    objects = objects.clone
    return remaining_number_of_lines if objects.size==0
    return remaining_number_of_lines if remaining_number_of_lines<=0
    object = objects.shift
    requirements = $requirement_operator.getObjectRequirements(object['uuid']).join(", ")
    requirements = requirements.size>0 ? " ( #{requirements} )".green : ''
    str = "(#{indx.to_s.rjust(2)}) #{object['announce']}#{requirements}"
    if object['metric']>=2 then
        str = str.green
    end
    puts str
    puts_objects(objects,remaining_number_of_lines-vertical_space(object['announce']), indx+1)
end

class RequirementsOperator

    def initialize()
        @data = nil
        @pathToDataFile = "/Galaxy/DataBank/Catalyst/requirements-structure/requirements-structure.json"
        self.loadDataFromDisk()
    end

    def loadDataFromDisk()
        @data = JSON.parse(IO.read(@pathToDataFile))
    end

    def saveDataToDisk()
        File.open(@pathToDataFile,'w') {|f| f.puts(JSON.pretty_generate(@data)) }
    end

    def currentHour()
        Time.new.to_s[0,13]
    end

    def getObjectRequirements(uuid)
        @data['items-requirements-distribution'][uuid] || []
    end

    def requirementIsSatisfied(requirement)
        @data['unsatisfied-requirements-timeline']["#{currentHour()};#{requirement}"].nil? or @data['unsatisfied-requirements-timeline']["#{currentHour()}/#{requirement}"]
    end

    def meetRequirements(uuid)
        self.getObjectRequirements(uuid)
            .all?{|requirement| self.requirementIsSatisfied(requirement) }
    end

    def addObjectRequirement(uuid,requirement)
        requirements = @data['items-requirements-distribution'][uuid] || []
        requirements << requirement
        requirements = requirements.uniq.sort
        @data['items-requirements-distribution'][uuid] = requirements
        self.saveDataToDisk()
    end

    def setRequirementOn(requirement)
        @data['unsatisfied-requirements-timeline']["#{currentHour()};#{requirement}"] = true
        self.saveDataToDisk()
    end

    def setRequirementOff(requirement)
        @data['unsatisfied-requirements-timeline']["#{currentHour()};#{requirement}"] = false
        self.saveDataToDisk()
    end

end

$requirement_operator = RequirementsOperator.new()

# -----------------------------------------------------------------

email_sync_on_schedule(true)

Thread.new { 
    loop {
        sleep 1200
        email_sync_on_schedule(false)
    }
}

firstrun = true

loop {
    
    TodaySectionManagement::performSync()
    DropOff::collectWaveObjects()
    DropOff::collectNinjaObjects()

    objects = CatalystCore::objects()
        .select{ |object| $requirement_operator.meetRequirements(object['uuid']) }
        .first(screen_height()-5)
    object = objects.first

    puts "# #{ "-" * (screen_width()-3) }".yellow
    
    remaining_number_of_lines = screen_height()-(7+vertical_space(object['announce']))
    puts_objects(objects.select{|object| object['metric'] > 0 },remaining_number_of_lines, 0)

    puts ""

    count = WaveDevOps::archivesGarbageCollection(true)
    if count>0 then
        LucilleCore::pressEnterToContinue()
        next
    end

    if firstrun then
        puts "Special General Commands:".green
        puts "    insert <wave item description>".green
        puts "    search <pattern>".green
        puts "    on <requirement>".green
        puts "    off <requirement>".green
        puts ""
        puts "Special Object Commands:".green
        puts "    requirement <requirement>".green
        puts ""
        firstrun = false
    end

    if object then
        puts_object_shell_display(object, objects)
    else
        sleep 30
    end

}

