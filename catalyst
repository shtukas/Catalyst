#!/usr/bin/ruby

# encoding: UTF-8
require 'json'
require 'date'
require 'colorize'
require 'securerandom'
# SecureRandom.hex    #=> "eb693ec8252cd630102fd0d0fb7c3485"
# SecureRandom.hex(4) #=> "eb693123"
# SecureRandom.uuid   #=> "2d931510-d99f-494a-8c67-87feb05e1594"
require 'fileutils'
# FileUtils.mkpath '/a/b/c'
# FileUtils.cp(src, dst)
# FileUtils.mv 'oldname', 'newname'
# FileUtils.rm(path_to_image)
# FileUtils.rm_rf('dir/to/remove')
require 'digest/sha1'
# Digest::SHA1.hexdigest 'foo'
# Digest::SHA1.file(myFile).hexdigest
require 'find'
require 'drb/drb'
require 'thread'
require "/Galaxy/local-resources/Ruby-Libraries/LucilleCore.rb"
require_relative "catalyst.rb"

require "/Galaxy/local-resources/Ruby-Libraries/KeyValueStore.rb"
=begin
    KeyValueStore::set(repositorylocation or nil, key, value)
    KeyValueStore::getOrNull(repositorylocation or nil, key)
    KeyValueStore::getOrDefaultValue(repositorylocation or nil, key, defaultValue)
    KeyValueStore::destroy(repositorylocation or nil, key)
=end

# -----------------------------------------------------------------

=begin

(DisplayState) {
    "nsx26:all-catalyst-objects"        => Array[CatalystObject],
    "nsx26:objects-already-processed"   => Array[CatalystObject],
    "nsx26:object-still-to-go"          => Array[CatalystObject],
    "nsx26:lines-to-display"            => Array[String],
    "nsx26:screen-left-height"          => 10,
    "nsx26:standard-listing-position"   => Int
    "nsx26:current-position-cursor"     => Int,
    "nsx26:should-stop-display-process" => Boolean
    "nsx26:focus-object"                => nil or object
}

=end

class DisplayStateUtils

    # DisplayStateUtils::makeGenesysDisplayState()
    def self.makeGenesysDisplayState(screenLeftHeight, standardlp) # : DisplayState
        objects = CommonsUtils::flockObjectsProcessedForCatalystDisplay()
        listsObjectsUUIDs = ListsOperator::allListsCatalystItemsUUID()
        regularObjects, listsObjects = objects.partition {|object| !listsObjectsUUIDs.include?(object["uuid"]) }
        {
            "nsx26:all-catalyst-objects"             => objects,
            "nsx26:objects-already-processed"        => [],
            "nsx26:object-still-to-go"               => regularObjects.sort{|o1,o2| o1['metric']<=>o2['metric'] }.reverse,
            "nsx26:lines-to-display"                 => [],
            "nsx26:screen-left-height"               => screenLeftHeight,
            "nsx26:standard-listing-position"        => standardlp,
            "nsx26:current-position-cursor"          => 0,
            "nsx26:should-stop-display-process"      => false,
            "nsx26:focus-object"                     => nil
        }
    end

    # DisplayStateUtils::displayStateTransition(displayState: DisplayState) : DisplayState
    def self.displayStateTransition(displayState) # return: DisplayState

        displayState["nsx26:current-position-cursor"] = displayState["nsx26:current-position-cursor"]+1
        displayState["nsx26:lines-to-display"] = []

        if displayState["nsx26:object-still-to-go"].size==0 then
            displayState["nsx26:should-stop-display-process"] = true
            return displayState
        end

        object = displayState["nsx26:object-still-to-go"].shift

        return nil if object["metric"] < 0.2 

        # --------------------------------------------------------------------------------
        if Bob::agentuuid2AgentData(object["agent-uid"]).nil? then
            EventsManager::commitEventToTimeline(EventsMaker::destroyCatalystObject(object["uuid"]))
            TheFlock::removeObjectIdentifiedByUUID(object["uuid"])
            return nil
        end

        # --------------------------------------------------------------------------------
        # Sometimes a wave item that is an email, gets deleted by the EmailClients process.
        # In such a case they are still in Flock and should not be showed
        if object["agent-uid"]=="283d34dd-c871-4a55-8610-31e7c762fb0d" then
            if object["schedule"][":wave-email:"] then
                if !File.exists?(object["item-data"]["folderpath"]) then
                    CatalystInterfaceUtils::executeCommandAgainstObject(object, "done", 1)
                    return DisplayStateUtils::displayStateTransition(displayState)
                end
            end
        end

        displayState["nsx26:objects-already-processed"] << object
        displayState["nsx26:lines-to-display"] << CatalystInterfaceUtils::objectToColoredLineForMainListing(object, displayState["nsx26:current-position-cursor"], displayState["nsx26:standard-listing-position"])
        displayState["nsx26:screen-left-height"] = displayState["nsx26:screen-left-height"] - 1 

        if displayState["nsx26:current-position-cursor"] == displayState["nsx26:standard-listing-position"] then
            displayState["nsx26:focus-object"] = object
            displayState["nsx26:lines-to-display"] << (" "*14)+CatalystInterfaceUtils::objectInferfaceString(object)
            displayState["nsx26:screen-left-height"] = displayState["nsx26:screen-left-height"] - 1 
        end

        if object["agent-uid"] == "201cac75-9ecc-4cac-8ca1-2643e962a6c6" then
            # We have a timeProton object
            displayState["nsx26:object-still-to-go"] = displayState["nsx26:object-still-to-go"]
                .map{|o| 
                    o["metric"] = o["metric"]-0.01 
                    o
                }
            loop {
                timeProton = object["item-data"]["timeProton"]
                break if timeProton["target"].nil?
                listuuid = timeProton["target"]
                list = ListsOperator::getListByUUIDOrNull(listuuid)
                break if list.nil?
                break if list["catalyst-object-uuids"].size==0
                ienum = LucilleCore::integerEnumerator() 
                displayState["nsx26:all-catalyst-objects"]
                    .select{|o| list["catalyst-object-uuids"].include?(o["uuid"]) }   
                    .sort{|o1,o2| o1["uuid"]<=>o2["uuid"] }
                    .map{|o|
                        o["metric"] = object["metric"] - 0.01*Math.exp(-ienum.next()) 
                        o[":is-timeProton-listing-7fdfb1be:"] = true # This is an unofficial marker for objects which have been positioned as followers of the first timeProton.
                        o
                    }
                    .each{|o|
                        displayState["nsx26:object-still-to-go"].unshift(o)
                    }
                break
            }

        end

        if displayState["nsx26:screen-left-height"] <= 0 then
            displayState["nsx26:should-stop-display-process"] = true
        end

        if displayState["nsx26:object-still-to-go"].count == 0 then
            displayState["nsx26:should-stop-display-process"] = true
        end

        displayState
    end
end

class CatalystInterfaceUtils

    # CatalystInterfaceUtils::objectInferfaceString(object)
    def self.objectInferfaceString(object)
        announce = object['announce'].strip
        defaultExpressionAsString = object["default-expression"] ? object["default-expression"] : ""
        requirements = RequirementsOperator::getObjectRequirements(object['uuid'])
        requirementsAsString = requirements.size>0 ? " ( #{requirements.join(" ")} )" : ''
        listIng = ListsOperator::getListsForCatalystObjectUUID(object["uuid"]).size > 0 ? " [ list(s): #{ListsOperator::getListsForCatalystObjectUUID(object["uuid"]).map{|list| list["description"] }.join(", ")} ]" : ""
        part2 = 
            [
                "#{requirementsAsString.green}",
                listIng,
                " (#{object["commands"].join(" ").red})",
                " \"#{defaultExpressionAsString.green}\""
            ].join()
        part2        
    end

    def self.objectToString(object)
        announce = object['announce'].strip
        defaultExpressionAsString = object["default-expression"] ? object["default-expression"] : ""
        requirements = RequirementsOperator::getObjectRequirements(object['uuid'])
        requirementsAsString = requirements.size>0 ? " ( #{requirements.join(" ")} )" : ''
        listIng = ListsOperator::getListsForCatalystObjectUUID(object["uuid"]).size > 0 ? " [list: #{ListsOperator::getListsForCatalystObjectUUID(object["uuid"]).map{|list| list["description"] }}]" : ""
        part1 = 
            [
                "(#{"%.3f" % object["metric"]})",
                " [#{object["uuid"]}]",
                " #{announce}",
            ].join()
        if object["is-running"] then
            part1 = part1.green
        end
        part2 = CatalystInterfaceUtils::objectInferfaceString(object)
        part1 + part2
    end

    def self.positionOfLastRunningItemOrZero(objects)
        return 0 if objects.none?{ |object| object["is-running"] }
        while !objects.last["is-running"] do
            objects.pop
        end
        objects.size
    end

    def self.displayObject(object, standardlp)
        if standardlp then
            puts "[  #{"%2d" % standardlp}] #{CatalystInterfaceUtils::objectToString(object)}"
        else
            puts CatalystInterfaceUtils::objectToString(object)
        end
    end

    def self.positionDisplay(standardlp, position)
        if standardlp and position and standardlp==position then
            "[* #{"%2d" % position}]"
        else
            if position then
                "[  #{"%2d" % position}]"
            else
                "[]"
            end
        end
    end

    def self.objectToLineForMainListing(object, position, standardlp)
        if position == standardlp then
            "#{CatalystInterfaceUtils::positionDisplay(standardlp, position)} #{CommonsUtils::objectToString(object)}"
        else
            "#{CatalystInterfaceUtils::positionDisplay(standardlp, position)} #{CommonsUtils::objectToString(object)[0,CommonsUtils::screenWidth()-9]}"
        end
    end

    def self.objectToColoredLineForMainListing(object, position, standardlp)
        str = CatalystInterfaceUtils::objectToLineForMainListing(object, position, standardlp)
        if object["metric"]>1 then
            str = str.yellow
        end
        if position == standardlp then
            str = str.colorize(:background => :light_blue)
        end
        if object["is-running"] then
            str = str.green
        end
        str
    end

    def self.executeCommandAgainstObject(object, command, standardlp)
        # The reason why we have this function and processObjectAndCommand as separate function is that they have different signatures
        # That having been said, it is true that this function could just rewrite the object and/or the command.
        if command == "." then
            return
        end
        if command == "+" then
            CommonsUtils::setStandardListingPosition(CommonsUtils::getStandardListingPosition()+1)
            return
        end
        if command.start_with?(":") then
            if CommonsUtils::isInteger(command[1, command.size]) then
                position = command[1, command.size].to_i
                CommonsUtils::setStandardListingPosition([position, 0].max)
                return
            end
            return
        end
        command = command.size>0 ? command : ( object["default-expression"] ? object["default-expression"] : "" )
        CommonsUtils::processObjectAndCommand(object, command)
    end

    def self.doDisplayObjectAndPromptAndReturnCommand(object, standardlp)
        CatalystInterfaceUtils::displayObject(object, standardlp)
        print "--> "
        command = STDIN.gets().strip
        command
    end

    def self.displayLoop(codehash)
        loop {

            if codehash != CommonsUtils::codeHash() then
                puts "Source code hash changed. Exiting!"
                exit
            end

            displayScreenSizeReductionIndex = 6

            # Indicates over staying off requirement.
            if ( Time.new.to_i > FKVStore::getOrDefaultValue("e138267d-2aff-4a34-99bf-e396e0ddb6cb", "0").to_i ) then
                if RequirementsOperator::getCurrentlyUnsatisfiedRequirements().size>0 then
                    puts "REQUIREMENTS OFF: #{RequirementsOperator::getCurrentlyUnsatisfiedRequirements().join(", ")}"
                    LucilleCore::pressEnterToContinue()
                end
                FKVStore::set("e138267d-2aff-4a34-99bf-e396e0ddb6cb", Time.new.to_i + Random::rand*3600*2)
                next
            end

            # Ensure that every list has a timeProton that drives it (list is a target of the timeProton)
            lists = ListsOperator::getLists()
            lists.each{|list|
                timeProtons = TimeProtonUtils::getTimeProtonsByTargetListUUID(list["list-uuid"])
                if timeProtons.size==0 then
                    puts "list: #{list["description"]} doesn't have a timeProton targetting it"
                    puts "Existing timeProtons: "
                    TimeProtonUtils::timeProtonsWithFilepaths()
                        .each{|pair|
                            timeProton, _ = pair
                            puts "    #{TimeProtonUtils::timeProtonToString(timeProton)}"
                        }
                    loop {
                        operation = LucilleCore::selectEntityFromListOfEntitiesOrNull("operation:", ["use existing timeProton", "create new timeProton", "destroy the list"])
                        next if operation.nil?
                        if operation == "use existing timeProton" then
                            puts "using an existing one:"
                            timeProton = TimeProtonUtils::interactivelySelectTimeProtonOrNull()
                            next if timeProton.nil?
                            if timeProton["target"] then
                                puts "The timeProton you have chosen already have a target"
                                LucilleCore::pressEnterToContinue()
                            else
                                timeProton["target"] = list["list-uuid"]
                                timeprotonfilepath = TimeProtonUtils::getTimeProtonFilepathFromItsUUIDOrNull(timeProton["uuid"])
                                TimeProtonUtils::commitTimeProtonToDisk(timeProton, File.basename(timeprotonfilepath))
                            end
                        end
                        if operation == "create new timeProton" then
                            puts "creating one:"
                            description = "timeProton for list '#{list["description"]}'"
                            timeCommitmentEvery20Hours = LucilleCore::askQuestionAnswerAsString("time commitment every day (every 20 hours): ").to_f
                            target = list["list-uuid"]
                            timeProton = TimeProtonUtils::makeNewTimeProton(description, timeCommitmentEvery20Hours, target)
                            puts JSON.pretty_generate(timeProton)
                            LucilleCore::pressEnterToContinue()
                        end
                        if operation == "destroy the list" then
                            ListsOperator::destroyList(list["list-uuid"])
                        end
                        break
                    }
                end
            }

            system("clear")

            standardlp = CommonsUtils::getStandardListingPosition()

            averageDailyCommitmentInHours = TimeProtonUtils::dailyCommitmentInHours()
            percentageDone = 100 * ( TimeProtonUtils::currentCollectivelyDoneInHours().to_f/averageDailyCommitmentInHours )

            numbers = TimeProtonDailyTimeTracking::numbersDayTotalAndPercentage()
            puts "Time Protons: #{"%.2f" % (numbers[0].to_f/3600)} hours today ( #{"%.2f" % (numbers[1])} % done )"

            puts ""

            if RequirementsOperator::getCurrentlyUnsatisfiedRequirements().size>0 then
                puts "REQUIREMENTS: OFF: #{RequirementsOperator::getCurrentlyUnsatisfiedRequirements().join(", ")}".yellow
            end

            focusobject = nil

            displayStateCloner = lambda { |displayState|
                newDisplayState = {}
                newDisplayState["nsx26:all-catalyst-objects"] = displayState["nsx26:all-catalyst-objects"].map{|o| o.clone }
                newDisplayState["nsx26:objects-already-processed"] = displayState["nsx26:objects-already-processed"].map{|o| o.clone }
                newDisplayState["nsx26:object-still-to-go"] = displayState["nsx26:object-still-to-go"].map{|o| o.clone }
                newDisplayState["nsx26:lines-to-display"] = displayState["nsx26:lines-to-display"].clone
                newDisplayState["nsx26:screen-left-height"] = displayState["nsx26:screen-left-height"]
                newDisplayState["nsx26:standard-listing-position"] = displayState["nsx26:standard-listing-position"]
                newDisplayState["nsx26:current-position-cursor"] = displayState["nsx26:current-position-cursor"]
                newDisplayState["nsx26:should-stop-display-process"] = displayState["nsx26:should-stop-display-process"]
                newDisplayState["nsx26:focus-object"] = displayState["nsx26:focus-object"] ? displayState["nsx26:focus-object"].clone : nil
                newDisplayState
            }

            displayStateToShowable = lambda { |displayState|
                newDisplayState = {}
                newDisplayState["nsx26:all-catalyst-objects"] = displayState["nsx26:all-catalyst-objects"].size
                newDisplayState["nsx26:objects-already-processed"] = displayState["nsx26:objects-already-processed"].size
                newDisplayState["nsx26:object-still-to-go"] = displayState["nsx26:object-still-to-go"].size
                newDisplayState["nsx26:lines-to-display"] = displayState["nsx26:lines-to-display"].clone
                newDisplayState["nsx26:screen-left-height"] = displayState["nsx26:screen-left-height"]
                newDisplayState["nsx26:standard-listing-position"] = displayState["nsx26:standard-listing-position"]
                newDisplayState["nsx26:current-position-cursor"] = displayState["nsx26:current-position-cursor"]
                newDisplayState["nsx26:should-stop-display-process"] = displayState["nsx26:should-stop-display-process"]
                newDisplayState["nsx26:focus-object"] = displayState["nsx26:focus-object"] ? displayState["nsx26:focus-object"].clone : nil
                newDisplayState
            }

            displayState = DisplayStateUtils::makeGenesysDisplayState(CommonsUtils::screenHeight()-displayScreenSizeReductionIndex, standardlp)
            loop {
                displayState["nsx26:lines-to-display"].each{|line|
                    puts line
                }
                #puts JSON.pretty_generate(displayStateToShowable.call(displayState))
                #LucilleCore::pressEnterToContinue()
                displayState = DisplayStateUtils::displayStateTransition(displayStateCloner.call(displayState))
                break if displayState.nil?
                #puts JSON.pretty_generate(displayStateToShowable.call(displayState))
                #LucilleCore::pressEnterToContinue()
                focusobject = displayState["nsx26:focus-object"]
                break if displayState["nsx26:should-stop-display-process"]
            }

            if focusobject.nil? then
                puts "Nothing to do for the moment (^_^)"
            end

            puts ""
            print "--> "
            command = STDIN.gets().strip

            if ( command == "..") and focusobject and focusobject["default-expression"] then
                command = focusobject["default-expression"]
            end

            if command == "" then
                next
            end

            shouldRemoveUnixtimeMark = lambda{|object, command|
                return true if command.include?("done")
                return true if command.start_with?("+")
                return true if ( object["agent-uid"]=="201cac75-9ecc-4cac-8ca1-2643e962a6c6" and command == "time:" ) # timeProton
                return true if ( object["agent-uid"]=="201cac75-9ecc-4cac-8ca1-2643e962a6c6" and command == "stop" ) # timeProton
                false
            }

            if focusobject and shouldRemoveUnixtimeMark.call(focusobject, command) then
                CyclesOperator::removeUnixtimeMark(focusobject["uuid"])
            end

            CatalystInterfaceUtils::executeCommandAgainstObject(focusobject, command, standardlp)

            if focusobject and focusobject["schedule"] and focusobject["schedule"][":wave-email:"] and command=="open" then
                if (command = LucilleCore::askQuestionAnswerAsString("Additional command? : ")).size>0 then
                    CatalystInterfaceUtils::executeCommandAgainstObject(focusobject, command, nil)
                end
            end

        }
    end
end

if !CommonsUtils::isLucille18() then
    puts "We are not running Catalyst outside Lucille18"
    exit
end


codehash = CommonsUtils::codeHash()
FlockDiskIO::loadFromEventsTimeline()

# -------------------------------------------------------------------------
=begin

The Task system

A task is a lambda and a period in seconds

We put the tasks into an array and loop over that array. 
This ewnsure that only one task run at the same time, that there is enough pause between two task and
that we run the tasks roughtly as often as they should run.

=end

# Task(taskUniqueId, period, lambda, name, shouldCausePromptAndReload)

$THETASKS = []
$THETASKS << [
    "49429DCB",
    86400,
    lambda {
         CatalystDevOps::archivesTimelineGarbageCollection(false)
    },
    "CatalystDevOps::archivesTimelineGarbageCollection(false)"
]
$THETASKS << [
    "59429DCB",
    86400,
    lambda {
         CatalystDevOps::eventsTimelineGarbageCollection(false)
    },
    "CatalystDevOps::eventsTimelineGarbageCollection(false)"
]
$THETASKS << [
    "69429DCB",
    1200,
    lambda {
         CommonsUtils::emailSync(false)
    },
    "CommonsUtils::emailSync(false)"
]
$THETASKS << [
    "79429DCB",
    60,
    lambda {
         FlockDiskIO::loadFromEventsTimeline()
    },
    "FlockDiskIO::loadFromEventsTimeline()"
]
$THETASKS << [
    "89429DCB",
    60,
    lambda {
         Bob::generalFlockUpgrade()
    },
    "Bob::generalFlockUpgrade()"
]

$THETASKSINDEX = 0
$THETASKSSHEDULING = JSON.parse(KeyValueStore::getOrDefaultValue(nil, "b0e73fa2-f035-4833-8945-b55f9463d87d", "{}"))

Thread.new {
    sleep 60
    loop {
        $THETASKSINDEX = ($THETASKSINDEX+1) % $THETASKS.size
        task = $THETASKS[$THETASKSINDEX]
        if Time.new.to_i - ( $THETASKSSHEDULING[task[0]] || 0 ) > task[1] then
            #puts "Task: #{task[3]}"
            task[2].call()
            $THETASKSSHEDULING[task[0]] = Time.new.to_i
            KeyValueStore::set(nil, "b0e73fa2-f035-4833-8945-b55f9463d87d", JSON.generate($THETASKSSHEDULING))
        end
        sleep 60
    }
}
# -------------------------------------------------------------------------

CatalystInterfaceUtils::displayLoop(codehash)
