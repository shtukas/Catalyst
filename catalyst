#!/usr/bin/ruby

# encoding: UTF-8

require 'json'

require 'date'

require 'colorize'

require 'securerandom'
# SecureRandom.hex    #=> "eb693ec8252cd630102fd0d0fb7c3485"
# SecureRandom.hex(4) #=> "eb693123"
# SecureRandom.uuid   #=> "2d931510-d99f-494a-8c67-87feb05e1594"

require "/Galaxy/LucilleOS/Misc-Resources/Ruby-Libraries/LucilleCore.rb"

require 'fileutils'
# FileUtils.mkpath '/a/b/c'
# FileUtils.cp(src, dst)
# FileUtils.mv 'oldname', 'newname'
# FileUtils.rm(path_to_image)
# FileUtils.rm_rf('dir/to/remove')

require_relative "CatalystCore.rb"

require_relative "Wave-Emails.rb"

# ----------------------------------------------------------------------------

CATALYST_DROPOFF_FOLDERPATH = "/Galaxy/DataBank/Catalyst/Wave-DropOff"
NINJA_DROPOFF_FOLDERPATH = "/Galaxy/DataBank/Catalyst/Ninja-DropOff"
NINJA_ITEMS_REPOSITORY_FOLDERPATH = "/Galaxy/DataBank/Ninja/Items"

class DropOff
    # DropOff::collectWaveObjects()
    def self.collectWaveObjects()
        Dir.entries(CATALYST_DROPOFF_FOLDERPATH)
            .select{|filename| filename[0, 1] != '.' }
            .map{|filename| "#{CATALYST_DROPOFF_FOLDERPATH}/#{filename}" }
            .each{|sourcelocation|
                uuid = SecureRandom.hex(4)
                description = 
                    if sourcelocation[-4,4] == '.txt' and IO.read(sourcelocation).lines.to_a.size == 1 then
                        IO.read(sourcelocation).strip
                    else
                        File.basename(sourcelocation)
                    end
                schedule = WaveSchedules::makeScheduleObjectNew()
                folderpath = WaveTimelineUtils::timestring22ToFolderpath(LucilleCore::timeStringL22())
                FileUtils.mkpath folderpath
                File.open("#{folderpath}/catalyst-uuid", 'w') {|f| f.write(uuid) }
                File.open("#{folderpath}/catalyst-description.txt", 'w') {|f| f.write(description) }
                WaveTimelineUtils::writeScheduleToDisk(uuid,schedule)
                if File.file?(sourcelocation) then
                    FileUtils.cp(sourcelocation,folderpath)
                else
                    FileUtils.cp_r(sourcelocation,folderpath)
                end
                File.open("#{folderpath}/wave-target-filename.txt", 'w') {|f| f.write(File.basename(sourcelocation)) }
                LucilleCore::removeFileSystemLocation(sourcelocation)
            }
    end
    # DropOff::collectNinjaObjects()
    def self.collectNinjaObjects()
        Dir.entries(NINJA_DROPOFF_FOLDERPATH)
            .select{|filename| filename[0, 1] != '.' }
            .map{|filename| "#{NINJA_DROPOFF_FOLDERPATH}/#{filename}" }
            .each{|sourcelocation|
                folderpath = "#{NINJA_ITEMS_REPOSITORY_FOLDERPATH}/#{Time.new.strftime("%Y")}/#{Time.new.strftime("%Y%m")}/#{Time.new.strftime("%Y%m%d")}/#{Time.new.strftime("%Y%m%d-%H%M%S-%6N")}-ninja"
                FileUtils.mkpath(folderpath)
                if File.file?(sourcelocation) then
                    FileUtils.cp(sourcelocation,folderpath)
                else
                    FileUtils.cp_r(sourcelocation,folderpath)
                end
                LucilleCore::removeFileSystemLocation(sourcelocation)
            }
    end
end

def email_downloads_on_schedule(verbose)
    if LucilleCore::trueNoMoreOftenThanNEverySeconds("29a504de-7985-493b-b809-332357bda3a7", 1200) then
        begin
            newEmailCount = GeneralEmailClient::downloadDataFromServer(JSON.parse(IO.read("/Galaxy/DataBank/Catalyst/Wave-Email-Config/guardian-relay.json")), verbose)
            if newEmailCount>0 then
                puts "Retrieved #{newEmailCount} new emails"
            end
            OperatorEmailDownloader::downloadDataFromServer(JSON.parse(IO.read("/Galaxy/DataBank/Catalyst/Wave-Email-Config/operator.json")), verbose)
            # We call again so that the clock restarts at the end of the process
            LucilleCore::trueNoMoreOftenThanNEverySecondsReset("29a504de-7985-493b-b809-332357bda3a7")
        rescue
        end
    end    
end

def screen_height()
    `/usr/bin/env tput lines`.to_i
end

def screen_width()
    `/usr/bin/env tput cols`.to_i
end

def vertical_space(announce)
    announce.lines.map{|line| (line.size/screen_width())+1 }.inject(0, :+)
end

def tokenIsInteger(token)
    token == token.to_i.to_s
end

def puts_object_shell_display(object, dislayobjects)
    
    dislayobjects = dislayobjects.clone

    # Here is the reason why the second argument was introduced
    # A first display is performed. 
    # You select number 8.
    # The list of objects is recomputed and the 8th (actually the 9th) one is selected.
    # There is no guaranty that the one selected was the one you were looking at since the objects
    # could have been reordered between the two computations.

    # Here:
    # If you select an ordinal, you get to apply it to the list you were looking at when you made that 
    # mental selection.

    puts object['announce'].strip

    if object['default-commands'] and object['default-commands'].size>0 then
        print object['default-commands'].join(" ; ").green
        print " ; "
    end

    puts object['commands'].join(", ").red
    print "---> "
    expression = STDIN.gets().strip

    # ---------------------
    # default commands

    if expression.size==0 and object['default-commands'] then
        object['default-commands'].each{|command|
            if command.start_with?('shell:') then
                command = command[7,command.size].strip
                system(command)
            else
                object['command-interpreter'].call(object, command)
            end
        }
        return
    end

    # ---------------------
    # regular expression: optional integer and commands

    def expression_decomposition(expression, dislayobjects)
        dislayobjects = dislayobjects.clone
        tokens = 
            if expression.start_with?('+') then
                [expression]
            else
                expression.split(' ').map{|t| t.strip }
            end
        if tokenIsInteger(tokens[0]) then
            targetObject = dislayobjects.drop(tokens[0].to_i).first # overriding the current object with the targetted object
            tokens.shift
            [targetObject, tokens]
        else
            [nil, tokens]
        end
    end

    targetObject, tokens = expression_decomposition(expression, dislayobjects)

    if targetObject and tokens.size==0 then
        puts_object_shell_display(targetObject, dislayobjects)
    end

    if targetObject and tokens.size>0 then
        tokens.each{|command|
            targetObject['command-interpreter'].call(targetObject, command)
        }
    end    

    if targetObject.nil? and tokens.size==0 then
        # Nothing to do 
    end

    if targetObject.nil? and tokens.size>0 then
        tokens.each{|command|
            object['command-interpreter'].call(object, command)
        }        
    end

end

def puts_objects(objects, remaining_number_of_lines, indx)
    objects = objects.clone
    return remaining_number_of_lines if objects.size==0
    return remaining_number_of_lines if remaining_number_of_lines<=0
    object = objects.shift
    str = "(#{indx.to_s.rjust(2)}) #{object['announce']}"
    if object['metric']>=2 then
        str = str.green
    end
    puts str
    puts_objects(objects,remaining_number_of_lines-vertical_space(object['announce']), indx+1)
end

# -----------------------------------------------------------------

loop {
    
    WaveDevOps::archivesGarbageCollection(true)
    email_downloads_on_schedule(false)
    TodaySectionManagement::performSync()
    DropOff::collectWaveObjects()
    DropOff::collectNinjaObjects()

    objects = CatalystCore::objects().first(screen_height()-5)
    object = objects.first

    puts "# -------------------------------------------------------"
    
    remaining_number_of_lines = screen_height()-(7+vertical_space(object['announce']))
    puts_objects(objects.select{|object| object['metric'] > 0 },remaining_number_of_lines, 0)

    puts ""

    if object then
        puts_object_shell_display(object, objects)
    else
        sleep 30
    end

}

