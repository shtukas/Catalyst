#!/usr/bin/ruby

# encoding: UTF-8
require 'json'
require 'date'
require 'colorize'
require 'securerandom'
# SecureRandom.hex    #=> "eb693ec8252cd630102fd0d0fb7c3485"
# SecureRandom.hex(4) #=> "eb693123"
# SecureRandom.uuid   #=> "2d931510-d99f-494a-8c67-87feb05e1594"
require 'fileutils'
# FileUtils.mkpath '/a/b/c'
# FileUtils.cp(src, dst)
# FileUtils.mv 'oldname', 'newname'
# FileUtils.rm(path_to_image)
# FileUtils.rm_rf('dir/to/remove')
require 'digest/sha1'
# Digest::SHA1.hexdigest 'foo'
# Digest::SHA1.file(myFile).hexdigest
require 'find'
require 'drb/drb'
require 'thread'
require "/Galaxy/local-resources/Ruby-Libraries/LucilleCore.rb"
require_relative "catalyst.rb"
# -----------------------------------------------------------------

class CatalystInterfaceUtils

    def self.makeGenesysDisplayState() # : DisplayState

    end

    # DisplayState = [ objectsAlreadyProcessed, objectsStillToGo, linesToDisplayAsASideEffectOfTheTransition, allListingObjects ]
    # When a DisplayState is returned from a transition step, then the linesToDisplayAsASideEffectOfTheTransition should be printed immediately
    # CatalystInterfaceUtils::displayStateTransition(displaystate: DisplayState) : DisplayState
    def self.displayStateTransition(displaystate) # return: DisplayState

    end

    # CatalystInterfaceUtils::objectInferfaceString(object)
    def self.objectInferfaceString(object)
        announce = object['announce'].strip
        defaultExpressionAsString = object["default-expression"] ? object["default-expression"] : ""
        requirements = RequirementsOperator::getObjectRequirements(object['uuid'])
        requirementsAsString = requirements.size>0 ? " ( #{requirements.join(" ")} )" : ''
        listIng = ListsOperator::getListsForCatalystObjectUUID(object["uuid"]).size > 0 ? " [list: #{ListsOperator::getListsForCatalystObjectUUID(object["uuid"]).map{|list| list["description"] }}]" : ""
        part2 = 
            [
                "#{requirementsAsString.green}",
                CommonsUtils::object2DonotShowUntilAsString(object),
                listIng,
                " (#{object["commands"].join(" ").red})",
                " \"#{defaultExpressionAsString.green}\""
            ].join()
        part2        
    end

    def self.object2Line_v1(object)
        announce = object['announce'].strip
        defaultExpressionAsString = object["default-expression"] ? object["default-expression"] : ""
        requirements = RequirementsOperator::getObjectRequirements(object['uuid'])
        requirementsAsString = requirements.size>0 ? " ( #{requirements.join(" ")} )" : ''
        listIng = ListsOperator::getListsForCatalystObjectUUID(object["uuid"]).size > 0 ? " [list: #{ListsOperator::getListsForCatalystObjectUUID(object["uuid"]).map{|list| list["description"] }}]" : ""
        part1 = 
            [
                "(#{"%.3f" % object["metric"]})",
                " [#{object["uuid"]}]",
                " #{announce}",
            ].join()
        if object["is-running"] then
            part1 = part1.green
        end
        part2 = CatalystInterfaceUtils::objectInferfaceString(object)
        part1 + part2
    end

    def self.positionOfLastRunningItemOrZero(objects)
        return 0 if objects.none?{ |object| object["is-running"] }
        while !objects.last["is-running"] do
            objects.pop
        end
        objects.size
    end

    def self.displayObject(object, standardlp)
        if standardlp then
            puts "[  #{"%2d" % standardlp}] #{CatalystInterfaceUtils::object2Line_v1(object)}"
        else
            puts CatalystInterfaceUtils::object2Line_v1(object)
        end
    end

    def self.positionDisplay(standardlp, position)
        if standardlp and position and standardlp==position then
            "[* #{"%2d" % position}]"
        else
            if position then
                "[  #{"%2d" % position}]"
            else
                "[]"
            end
        end
    end

    def self.objectToLineMainListing(object, position, standardlp)
        if position == standardlp then
            "#{CatalystInterfaceUtils::positionDisplay(standardlp, position)} #{CommonsUtils::object2Line_v0(object)}"
        else
            "#{CatalystInterfaceUtils::positionDisplay(standardlp, position)} #{CommonsUtils::object2Line_v0(object)[0,CommonsUtils::screenWidth()-9]}"
        end
    end

    def self.objectToLineMainListingLambdaWithColour(object, position, standardlp)
        str = CatalystInterfaceUtils::objectToLineMainListing(object, position, standardlp)
        if object["metric"]>1 then
            str = str.yellow
        end
        if position == standardlp then
            str = str.colorize(:background => :light_blue)
        end
        if object["is-running"] then
            str = str.green
        end
        str
    end

    def self.executeCommandAgainstObject(object, command, standardlp, displayobjects)
        # The reason why we have this function and processObjectAndCommand as separate function is that they have different signatures
        # That having been said, it is true that this function could just rewrite the object and/or the command.
        if command == "." then
            return
        end
        if command == "+" then
            CommonsUtils::setStandardListingPosition(CommonsUtils::getStandardListingPosition()+1)
            return
        end
        if command.start_with?(":") then
            if CommonsUtils::isInteger(command[1, command.size]) then
                position = command[1, command.size].to_i
                CommonsUtils::setStandardListingPosition([position, 0].max)
                return
            end
            return
        end
        command = command.size>0 ? command : ( object["default-expression"] ? object["default-expression"] : "" )
        CommonsUtils::processObjectAndCommand(object, command)
    end

    def self.processObjectForMetricRequirement(object, displayobjects)
        puts ""
        displayobjects
            .select{|object| object["metric"]>1 }
            .each{|object|
                puts CatalystInterfaceUtils::objectToLineMainListingLambdaWithColour(object, nil, nil) 
            }
        puts ""
        puts "Middle of week day:"
        puts "Processing object for metric requirements (do, postpone, or metric <metric>):"
        command = CatalystInterfaceUtils::doDisplayObjectAndPromptAndReturnCommand(object, nil)
        CatalystInterfaceUtils::executeCommandAgainstObject(object, command, nil, nil)
    end

    def self.doDisplayObjectAndPromptAndReturnCommand(object, standardlp)
        CatalystInterfaceUtils::displayObject(object, standardlp)
        print "--> "
        command = STDIN.gets().strip
        command
    end

    def self.displayLoop(codehash)
        loop {

            if codehash != CommonsUtils::codeHash() then
                puts "Source code hash changed. Exiting!"
                exit
            end
            
            displayScreenSizeReductionIndex = 6

            # Indicates over staying off requirement.
            if ( Time.new.to_i > FKVStore::getOrDefaultValue("e138267d-2aff-4a34-99bf-e396e0ddb6cb", "0").to_i ) then
                if RequirementsOperator::getCurrentlyUnsatisfiedRequirements().size>0 then
                    puts "REQUIREMENTS OFF: #{RequirementsOperator::getCurrentlyUnsatisfiedRequirements().join(", ")}"
                    LucilleCore::pressEnterToContinue()
                end
                FKVStore::set("e138267d-2aff-4a34-99bf-e396e0ddb6cb", Time.new.to_i + Random::rand*3600*2)
                next
            end

            # Ensure that every list has a lisa that drives it (list is a target of the lisa)
            lists = ListsOperator::getLists()
            lists.each{|list|
                lisas = LisaUtils::getLisasByTargetListUUID(list["list-uuid"])
                if lisas.size==0 then
                    puts "list: #{list["description"]} doesn't have a lisa targetting it"
                    puts "Existing lisas: "
                    LisaUtils::lisasWithFilepaths()
                        .each{|pair|
                            lisa, _ = pair
                            puts "    #{LisaUtils::lisaToString_v1(lisa, 40, 50)}"
                        }
                    loop {
                        operation = LucilleCore::selectEntityFromListOfEntitiesOrNull("operation:", ["use existing lisa", "create new lisa", "destroy the list"])
                        next if operation.nil?
                        if operation == "use existing lisa" then
                            puts "using an existing one:"
                            lisa = LisaUtils::interactivelySelectLisaOrNull()
                            next if lisa.nil?
                            if lisa["target"] then
                                puts "The lisa you have chosen already have a target"
                                LucilleCore::pressEnterToContinue()
                            else
                                lisa["target"] = ["list", list["list-uuid"]]
                                lisafilepath = LisaUtils::getLisaFilepathFromLisaUUIDOrNull(lisa["uuid"])
                                LisaUtils::commitLisaToDisk(lisa, File.basename(lisafilepath))
                            end
                        end
                        if operation == "create new lisa" then
                            puts "creating one:"
                            description = "lisa for list '#{list["description"]}'"
                            timeCommitmentInHours = LucilleCore::askQuestionAnswerAsString("time commitment in hours: ").to_f
                            timeUnitInDays = LucilleCore::askQuestionAnswerAsString("time unit in days: ").to_f
                            timestructure = { "time-commitment-in-hours"=> timeCommitmentInHours.to_f, "time-unit-in-days" => timeUnitInDays.to_f }
                            repeat = LucilleCore::askQuestionAnswerAsBoolean("should repeat?: ")
                            target = ["list", list["list-uuid"]]
                            lisa = LisaUtils::spawnNewLisa(description, timestructure, repeat, target)
                            puts JSON.pretty_generate(lisa)
                            LucilleCore::pressEnterToContinue()
                        end
                        if operation == "destroy the list" then
                            ListsOperator::destroyList(list["list-uuid"])
                        end
                        break
                    }
                end
            }

            # Ensure that every lisa has a time commitment greater than 0
            LisaUtils::lisasWithFilepaths()
                .each{|pair|
                    lisa, filepath = pair
                    next if lisa["time-structure"]["time-commitment-in-hours"] > 0
                    puts "The following lisa has a time commitment equal to zero"
                    puts JSON.pretty_generate(lisa)
                    timeCommitmentInHours = LucilleCore::askQuestionAnswerAsString("time commitment in hours: ").to_f
                    timeUnitInDays = LucilleCore::askQuestionAnswerAsString("time unit in days: ").to_f
                    timestructure = { "time-commitment-in-hours"=> timeCommitmentInHours.to_f, "time-unit-in-days" => timeUnitInDays.to_f }
                    lisa["time-structure"] = timestructure
                    LisaUtils::commitLisaToDisk(lisa, File.basename(filepath))
                }

            system("clear")

            averageDailyCommitmentInHours = LisaUtils::dailyCommitmentInHours()
            percentageDone = 100 * ( LisaUtils::currentCollectivelyDoneInHours().to_f/averageDailyCommitmentInHours )

            puts "Lisa: #{"%.2f" % averageDailyCommitmentInHours} hours today ( #{"%.2f" % percentageDone} % done )"

            standardlp = CommonsUtils::getStandardListingPosition()
            displayobjects = CommonsUtils::flockDisplayObjects()

            if displayobjects.size==0 then
                puts "-> I can't find any catalyst object. Is that expected ?"
                LucilleCore::pressEnterToContinue()
                next
            end            

            focusobject = displayobjects.clone.take([standardlp, displayobjects.size].min).last

            # --------------------------------------------------------------------------------
            # Checking that the object about to display is not orphan
            if Bob::agentuuid2AgentData(focusobject["agent-uid"]).nil? then
                LucilleCore::pressEnterToContinue()
                EventsManager::commitEventToTimeline(EventsMaker::destroyCatalystObject(focusobject["uuid"]))
                TheFlock::removeObjectIdentifiedByUUID(focusobject["uuid"])
                next
            end
            # --------------------------------------------------------------------------------

            # --------------------------------------------------------------------------------
            # Sometimes a wave item that is an email, gets deleted by the EmailClients process.
            # In such a case they are still in Flock and should not be showed
            if focusobject["agent-uid"]=="283d34dd-c871-4a55-8610-31e7c762fb0d" then
                if focusobject["schedule"][":wave-email:"] then
                    if !File.exists?(focusobject["item-data"]["folderpath"]) then
                        TheFlock::removeObjectIdentifiedByUUID(focusobject["uuid"])
                        EventsManager::commitEventToTimeline(EventsMaker::destroyCatalystObject(focusobject["uuid"]))
                        next
                    end
                end
            end
            # --------------------------------------------------------------------------------

            # --------------------------------------------------------------------------------
            # Listing display

            puts ""

            amountToDisplay = [ CommonsUtils::screenHeight()-displayScreenSizeReductionIndex, self.positionOfLastRunningItemOrZero(displayobjects.clone) ].max
            displayObjectsScreenFitting = displayobjects.clone.take(amountToDisplay)
            if RequirementsOperator::getCurrentlyUnsatisfiedRequirements().size>0 then
                puts "REQUIREMENTS: OFF: #{RequirementsOperator::getCurrentlyUnsatisfiedRequirements().join(", ")}".yellow
                displayObjectsScreenFitting.pop
            end
            displayObjectsScreenFitting.each_with_index{|xobject, position|
                puts CatalystInterfaceUtils::objectToLineMainListingLambdaWithColour(xobject, position+1, standardlp)
                if position+1 == standardlp then
                    puts (" "*14)+CatalystInterfaceUtils::objectInferfaceString(xobject)
                end
            }
            # --------------------------------------------------------------------------------

            puts ""
            print "--> "
            command = STDIN.gets().strip

            shouldRemoveUnixtimeMark = lambda{|object, command|
                return true if command == "done"
                return true if command.start_with?("+")
                false
            }

            if shouldRemoveUnixtimeMark.call(focusobject, command) then
                CyclesOperator::removeUnixtimeMark(focusobject["uuid"])
            end

            CatalystInterfaceUtils::executeCommandAgainstObject(focusobject, command, standardlp, displayobjects.clone)

            if focusobject["schedule"] and focusobject["schedule"][":wave-email:"] and ( command == "open" ) then
                if (command = LucilleCore::askQuestionAnswerAsString("Additional command? : ")).size>0 then
                    CatalystInterfaceUtils::executeCommandAgainstObject(focusobject, command, nil, nil)
                end
            end

        }
    end
end

codehash = CommonsUtils::codeHash()
FlockDiskIO::loadFromEventsTimeline()

Thread.new {
    loop {
        sleep 60 * ( 1 + rand )
        if CommonsUtils::isLucille18() and CommonsUtils::trueNoMoreOftenThanNEverySeconds(nil, "ddb51cb6-7fd7-4737-90af-2c6524449937", 86400) then
            CatalystDevOps::archivesTimelineGarbageCollection(false)
        end
    }
}

Thread.new {
    loop {
        sleep 60 * ( 1 + rand )
        if CommonsUtils::isLucille18() and CommonsUtils::trueNoMoreOftenThanNEverySeconds(nil, "4b896858-bc31-407b-9c8f-3e890b408c75", 86400) then
            CatalystDevOps::eventsTimelineGarbageCollection(false)
        end
    }
}

Thread.new {
    loop {
        sleep 60 * ( 1 + rand )
        if CommonsUtils::isLucille18() and CommonsUtils::trueNoMoreOftenThanNEverySeconds(nil, "73672434-e76a-4cfd-8404-168863e9b681", 3600) then
            CommonsUtils::emailSync(false)
        end
    }
}

Thread.new {
    loop {
        sleep 60 * ( 1 + rand )
        if CommonsUtils::trueNoMoreOftenThanNEverySeconds(nil, "0daa5393-d43f-4e4f-a9e0-9776a5c8ec46", 300) then
            FlockDiskIO::loadFromEventsTimeline()
        end
    }
}

Thread.new {
    loop {
        # Bob::generalFlockUpgrade, to send screen notifications on overdoing lisas.
        sleep 60 * ( 1 + rand )
        Bob::generalFlockUpgrade()
    }
}

CatalystInterfaceUtils::displayLoop(codehash)
