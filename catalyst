#!/usr/bin/ruby

# encoding: UTF-8
require 'json'
require 'date'
require 'colorize'
require 'securerandom'
# SecureRandom.hex    #=> "eb693ec8252cd630102fd0d0fb7c3485"
# SecureRandom.hex(4) #=> "eb693123"
# SecureRandom.uuid   #=> "2d931510-d99f-494a-8c67-87feb05e1594"
require 'fileutils'
# FileUtils.mkpath '/a/b/c'
# FileUtils.cp(src, dst)
# FileUtils.mv 'oldname', 'newname'
# FileUtils.rm(path_to_image)
# FileUtils.rm_rf('dir/to/remove')
require 'digest/sha1'
# Digest::SHA1.hexdigest 'foo'
# Digest::SHA1.file(myFile).hexdigest
require 'find'
require 'drb/drb'
require 'thread'
require "/Galaxy/Software/Misc-Common/Ruby-Libraries/LucilleCore.rb"

# -----------------------------------------------------------------

require_relative "NSXConstants.rb"

require_relative "NSXMiscLibraries/NSXMiscUtils.rb"
require_relative "NSXMiscLibraries/NSXStringParser.rb"

require_relative "NSXSystemLibraries/NSXDoNotShowUntilDatetime.rb"
require_relative "NSXSystemLibraries/NSXCanary.rb"
require_relative "NSXSystemLibraries/NSXCatalystDevOps.rb"
require_relative "NSXSystemLibraries/NSXCatalystMetadataInterface.rb"
require_relative "NSXSystemLibraries/NSXCyclesOperator.rb"
require_relative "NSXSystemLibraries/NSXDayBucketOperator.rb"
require_relative "NSXSystemLibraries/NSXEmailClients.rb"
require_relative "NSXSystemLibraries/NSXRequirementsOperator.rb"

require_relative "NSXAgentsLibraries/NSXFolderProbe.rb"
require_relative "NSXAgentsLibraries/NSXLightThreadUtils.rb"
require_relative "NSXAgentsLibraries/NSXOrdinals.rb"

require_relative "NSXAgents/NSXAgentBabyNights.rb"
require_relative "NSXAgents/NSXAgentHouse.rb"
require_relative "NSXAgents/NSXAgentLightThread.rb"
require_relative "NSXAgents/NSXAgentNinja.rb"
require_relative "NSXAgents/NSXAgentOrdinals.rb"
require_relative "NSXAgents/NSXAgentVienna.rb"
require_relative "NSXAgents/NSXAgentWave.rb"
require_relative "NSXAgents/NSXAgentWIS.rb"

require_relative "NSXBob.rb"

require_relative "NSXDataManager/NSXDataManager.rb"
require_relative "NSXDisplayOperator.rb"
require_relative "NSXGeneralCommandHandler.rb"

# -------------------------------------------------------------------------
=begin

The Task system

A task is a lambda and a period in seconds

We put the tasks into an array and loop over that array. 
This ewnsure that only one task run at the same time, that there is enough pause between two task and
that we run the tasks roughtly as often as they should run.

=end

# Task(taskUniqueId, period, lambda, name, shouldCausePromptAndReload)

$THETASKS = []
$THETASKS << [
    "49429DCB",
    86400,
    lambda {
         NSXCatalystDevOps::archivesTimelineGarbageCollection(false)
    },
    "NSXCatalystDevOps::archivesTimelineGarbageCollection(false)"
]
$THETASKS << [
    "69429DCB",
    1200,
    lambda {
         NSXMiscUtils::emailSync(false)
    },
    "NSXMiscUtils::emailSync(false)"
]

$THETASKSINDEX = 0
$THETASKSSHEDULING = NSXSystemDataOperator::getOrDefaultValue("b0e73fa2-f035-4833-8945-b55f9463d87d", {})

Thread.new {
    sleep 60
    loop {
        $THETASKSINDEX = ($THETASKSINDEX+1) % $THETASKS.size
        task = $THETASKS[$THETASKSINDEX]
        if Time.new.to_i - ( $THETASKSSHEDULING[task[0]] || 0 ) > task[1] then
            #puts "Task: #{task[3]}"
            task[2].call()
            $THETASKSSHEDULING[task[0]] = Time.new.to_i
            NSXSystemDataOperator::set("b0e73fa2-f035-4833-8945-b55f9463d87d", $THETASKSSHEDULING)
        end
        sleep 60
    }
}

# -------------------------------------------------------------------------

Thread.new {
    loop {
        sleep 120
        NSXCatalystObjectsOperator::getObjectsFromAgents()
    }
}

# -------------------------------------------------------------------------

loop {

    displayScreenSizeReductionIndex = 5

    # Indicates over staying off requirement.
    if Time.new.to_i > NSXSystemDataOperator::getOrDefaultValue("e138267d-2aff-4a34-99bf-e396e0ddb6cb", "0").to_i then
        if NSXRequirementsOperator::getCurrentlyUnsatisfiedRequirements().size>0 then
            puts "REQUIREMENTS OFF: #{NSXRequirementsOperator::getCurrentlyUnsatisfiedRequirements().join(", ")}"
            LucilleCore::pressEnterToContinue()
        end
        NSXSystemDataOperator::set("e138267d-2aff-4a34-99bf-e396e0ddb6cb", Time.new.to_i + Random::rand*3600*2)
        next
    end

    system("clear")

    puts "Special Commands Object: ,, .. ordinal: <ordinal> // <timeEstimationInHours> +datetimecode, +<weekdayname>, +<integer>day(s), +<integer>hour(s), +YYYY-MM-DD, expose, require <requirement>, requirement remove <requirement>, >thread, >bucket".green

    standardlp = NSXMiscUtils::getStandardListingPosition()

    puts ""

    if NSXRequirementsOperator::getCurrentlyUnsatisfiedRequirements().size>0 then
        puts "REQUIREMENTS: OFF: #{NSXRequirementsOperator::getCurrentlyUnsatisfiedRequirements().join(", ")}".yellow
    end

    focusobject = NSXDisplayOperator::printScreen(displayScreenSizeReductionIndex, standardlp)

    if focusobject.nil? then
        puts "Nothing to do for the moment (^_^)"
    end

    puts ""
    print "--> "
    command = STDIN.gets().strip

    if ( command == "..") and focusobject and focusobject["default-expression"] then
        command = focusobject["default-expression"]
    end

    if command == ';;' then
        command = 'open; done'
    end

    if command == "" then
        next
    end

    shouldRemoveUnixtimeMark = lambda{|object, command|
        return true if command.include?("done")
        return true if command.start_with?("+")
        return true if ( object["agent-uid"]=="201cac75-9ecc-4cac-8ca1-2643e962a6c6" and command == "time:" ) # lightThread
        return true if ( object["agent-uid"]=="201cac75-9ecc-4cac-8ca1-2643e962a6c6" and command == "stop" ) # lightThread
        false
    }

    if focusobject and shouldRemoveUnixtimeMark.call(focusobject, command) then
        NSXCatalystMetadataInterface::unSetMetricCycleUnixtimeForObject(focusobject["uuid"])
    end

    NSXGeneralCommandHandler::processCommand(focusobject, command)

    if command=="open" and focusobject and focusobject["schedule"] and focusobject["schedule"][":wave-email:"] then
        if (command = LucilleCore::askQuestionAnswerAsString("Additional command? : ")).size>0 then
            NSXGeneralCommandHandler::processCommand(focusobject, command)
        end
    end

}

