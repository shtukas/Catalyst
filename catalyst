#!/usr/bin/ruby

# encoding: UTF-8

require 'json'

require 'date'

require 'colorize'

require 'securerandom'
# SecureRandom.hex    #=> "eb693ec8252cd630102fd0d0fb7c3485"
# SecureRandom.hex(4) #=> "eb693123"
# SecureRandom.uuid   #=> "2d931510-d99f-494a-8c67-87feb05e1594"

require "/Galaxy/local-resources/Ruby-Libraries/LucilleCore.rb"

require 'fileutils'
# FileUtils.mkpath '/a/b/c'
# FileUtils.cp(src, dst)
# FileUtils.mv 'oldname', 'newname'
# FileUtils.rm(path_to_image)
# FileUtils.rm_rf('dir/to/remove')

require_relative "CatalystObjects.rb"

require_relative "Wave-Emails.rb"

require "/Galaxy/local-resources/Ruby-Libraries/KeyValueStore.rb"
=begin
    KeyValueStore::set(repositorypath or nil, key, value)
    KeyValueStore::getOrNull(repositorypath or nil, key)
    KeyValueStore::getOrDefaultValue(repositorypath or nil, key, defaultValue)
    KeyValueStore::destroy(repositorypath or nil, key)
=end

require "/Galaxy/LucilleOS/Librarian/LibrarianExportedFunctions.rb"

require 'digest/sha1'
# Digest::SHA1.hexdigest 'foo'
# Digest::SHA1.file(myFile).hexdigest

require 'find'


# ----------------------------------------------------------------------

class RequirementsOperator

    @@pathToDataFile = nil
    @@data = nil

    def self.init()
        @@pathToDataFile = "/Galaxy/DataBank/Catalyst/requirements/requirements-structure.json"
        @@data = JSON.parse(IO.read(@@pathToDataFile))
    end

    def self.saveDataToDisk()
        File.open(@@pathToDataFile, 'w') {|f| f.puts(JSON.pretty_generate(@@data)) }
    end

    def self.getObjectRequirements(uuid)
        @@data['items-requirements-distribution'][uuid] || []
    end

    def self.requirementIsCurrentlySatisfied(requirement)
        @@data['requirements-status-timeline'][requirement].nil? or @@data['requirements-status-timeline'][requirement]
    end

    def self.meetRequirements(uuid)
        RequirementsOperator::getObjectRequirements(uuid)
            .all?{|requirement| RequirementsOperator::requirementIsCurrentlySatisfied(requirement) }
    end

    def self.addObjectRequirement(uuid,requirement)
        requirements = @@data['items-requirements-distribution'][uuid] || []
        requirements << requirement
        requirements = requirements.uniq.sort
        @@data['items-requirements-distribution'][uuid] = requirements
        RequirementsOperator::saveDataToDisk()
    end

    def self.setRequirementOn(requirement)
        @@data['requirements-status-timeline'][requirement] = true
        RequirementsOperator::saveDataToDisk()
    end

    def self.setRequirementOff(requirement)
        @@data['requirements-status-timeline'][requirement] = false
        RequirementsOperator::saveDataToDisk()
    end

    def self.allRequirements()
        @@data['items-requirements-distribution'].values.flatten.uniq
    end

    def self.currentlyUnsatisfifiedRequirements()
        RequirementsOperator::allRequirements().select{|requirement| !RequirementsOperator::requirementIsCurrentlySatisfied(requirement) }
    end
end

# Jupiter::Jupiter::emailSyncOnSchedule(verbose)
# Jupiter::screenHeight()
# Jupiter::screenWidth()
# Jupiter::verticalSpace(announce)
# Jupiter::tokenIsInteger(token)
# Jupiter::execute(expression, object, displayObjects): (directive, value) # See documentation for details
# Jupiter::putsObjectWithShellDisplay(object, displayObjects): (directive, value) # See documentation for details
# Jupiter::objectToStringLine(object, indx)
# Jupiter::putsObjects(objects, remaining_number_of_lines: Int, indx: Int)
# Jupiter::putshelp()
# Jupiter::editTextUsingTextmate(text)
# Jupiter::processItemDescriptionPossiblyAsTextEditorInvitation(description)
# Jupiter::selectDisplayObjects()
# Jupiter::main()

class Jupiter
    def self.emailSyncOnSchedule(verbose)
        if LucilleCore::trueNoMoreOftenThanNEverySeconds("29a504de-7985-493b-b809-332357bda3a7", 1200) then
            begin
                newEmailCount = GeneralEmailClient::syncEmailDataWithServer(JSON.parse(IO.read("/Galaxy/DataBank/Catalyst/Wave/Wave-Email-Config/guardian-relay.json")), verbose)
                if newEmailCount>0 then
                    puts "Retrieved #{newEmailCount} new emails"
                end
                OperatorEmailDownloader::syncEmailDataWithServer(JSON.parse(IO.read("/Galaxy/DataBank/Catalyst/Wave/Wave-Email-Config/operator.json")), verbose)
                # We call again so that the clock restarts at the end of the process
                LucilleCore::trueNoMoreOftenThanNEverySecondsReset("29a504de-7985-493b-b809-332357bda3a7")
            rescue
            end
        end    
    end

    def self.screenHeight()
        `/usr/bin/env tput lines`.to_i
    end

    def self.screenWidth()
        `/usr/bin/env tput cols`.to_i
    end

    def self.verticalSpace(announce)
        announce.lines.map{|line| (line.size/Jupiter::screenWidth())+1 }.inject(0, :+)
    end

    def self.tokenIsInteger(token)
        token == token.to_i.to_s
    end

    def self.execute(expression, object, displayObjects)

        if expression == 'help' then
            Jupiter::putshelp()
            LucilleCore::pressEnterToContinue()
            return [nil, false]
        end

        if expression == 'expose' then
            puts JSON.pretty_generate(object)
            LucilleCore::pressEnterToContinue()
            return [nil, true]
        end

        if expression == 'info' then
            puts "WaveDevOps::getArchiveSizeInMegaBytes(): #{WaveDevOps::getArchiveSizeInMegaBytes()}"
            puts "Stream item count: #{Stream::getUUIDs().size}"
            puts "x-laniakea item count: #{FIFOQueue::values(nil, "2477F469-6A18-4CAF-838A-E05703585A28").count}"
            LucilleCore::pressEnterToContinue()
            return [nil, false]
        end

        if expression == 'lib' then
            LibrarianExportedFunctions::librarianUserInterface_librarianInteractive()
            return [nil, false]
        end

        if expression.start_with?('+') then
            code = expression
            datetime = Jupiter::datetimeSpecification2232ToDatetime(code)
            DoNotShowUntil::set(object["uuid"], datetime)
            return [nil, false]
        end

        if expression.start_with?('wave:') then
            description = expression[5, expression.size].strip
            description = Jupiter::processItemDescriptionPossiblyAsTextEditorInvitation(description)
            uuid = SecureRandom.hex(4)
            schedule = WaveSchedules::makeScheduleObjectInteractivelyOrNull()
            folderpath = WaveTimelineUtils::timestring22ToFolderpath(LucilleCore::timeStringL22())
            FileUtils.mkpath folderpath
            File.open("#{folderpath}/catalyst-uuid", 'w') {|f| f.write(uuid) }
            File.open("#{folderpath}/catalyst-description.txt", 'w') {|f| f.write(description) }
            WaveTimelineUtils::writeScheduleToDisk(uuid, schedule)
            return [nil, false]
        end

        if expression.start_with?('stream:') then
            description = expression[7, expression.size].strip
            description = Jupiter::processItemDescriptionPossiblyAsTextEditorInvitation(description)
            folderpath = "#{CATALYST_COMMON_PATH_TO_STREAM_DOMAIN_FOLDER}/strm2/#{LucilleCore::timeStringL22()}"
            FileUtils.mkpath folderpath
            File.open("#{folderpath}/description.txt", 'w') {|f| f.write(description) }
            return [nil, false]
        end

        if expression.start_with?("search") then
            pattern = expression[6,expression.size].strip
            searchobjects = CatalystCore::objects()
                .select{|object| object['announce'].downcase.include?(pattern.downcase) }
            if searchobjects.size>0 then
                loop {
                    searchobject = LucilleCore::interactivelySelectEntityFromListOfEntitiesOrNull("object: ", searchobjects, lambda{ |item| item['announce'] })
                    break if searchobject.nil?
                    Jupiter::putsObjectWithShellDisplay(searchobject, displayObjects)
                }
            end
            return [nil, false]
        end

        if expression.start_with?("require") then
            requirement = expression[7,expression.size].strip
            RequirementsOperator::addObjectRequirement(object['uuid'],requirement)
            return [nil, false]
        end

        if expression.start_with?("on") then
            command, requirement = expression.split(" ")
            RequirementsOperator::setRequirementOn(requirement)
            return [nil, false]
        end

        if expression.start_with?("off") then
            command, requirement = expression.split(" ")    
            RequirementsOperator::setRequirementOff(requirement)
            return [nil, false]
        end

        if expression.start_with?("show") then
            command, requirement = expression.split(" ")
            requirementObjects = CatalystCore::objects()
                .select{ |object| RequirementsOperator::getObjectRequirements(object['uuid']).include?(requirement) }
                .each{|object|
                    puts Jupiter::objectToStringLine(object)
                }
            LucilleCore::pressEnterToContinue()
            return [nil, false]
        end

        if Jupiter::tokenIsInteger(expression) then
            indx = expression.to_i
            targetObject = displayObjects.drop(indx).first
            return Jupiter::putsObjectWithShellDisplay(targetObject, displayObjects)
        end

        if expression.split(" ").size>0 and Jupiter::tokenIsInteger(expression.split(" ").first) then
            indx = expression.split(" ").first.to_i
            expression = expression[indx.to_s.size,expression.size].strip
            targetObject = displayObjects.drop(indx).first
            return [nil, false] if targetObject.nil?
            return Jupiter::execute(expression, targetObject, [])
        end

        if expression.size > 0 then
            tokens = expression.split(' ').map{|t| t.strip }
            if tokens.size>1 then
                returnValues = tokens.map{|command|
                    object['command-interpreter'].call(object, command)
                }
                if returnValues.any?{|value| value.nil? } then
                    return nil
                end
                return [nil, false]
            else
                return object['command-interpreter'].call(object, tokens[0])
            end
        else
            return object['command-interpreter'].call(object, "")
        end
    end

    def self.putsObjectWithShellDisplay(object, displayObjects)
        requirements = RequirementsOperator::getObjectRequirements(object['uuid']).join(", ")
        requirements = requirements.size>0 ? " ( #{requirements} )".green : ''
        puts "#{object['announce'].strip}#{requirements}"
        if object['commands'].size>0 then
            puts object['commands'].join(" ").red
        end
        print "---> "
        expression = STDIN.gets().strip
        execReturnValue = Jupiter::execute(expression, object, displayObjects)
        if expression.size>0 and execReturnValue.nil? then
            puts "Expression: #{expression} was not correctly interpreted"
            LucilleCore::pressEnterToContinue()
            return [nil, false]
        end
        directive, value = execReturnValue
        if directive.nil? and value then
            return Jupiter::putsObjectWithShellDisplay(object, displayObjects) 
        end
        if directive=="object-to-display" then
            return Jupiter::putsObjectWithShellDisplay(value, displayObjects) 
        end
        [nil, false]
    end

    def self.objectToStringLine(object, indx = nil)
        requirements = RequirementsOperator::getObjectRequirements(object['uuid']).join(", ")
        requirements = requirements.size>0 ? " ( #{requirements} )".green : ''
        indexString = indx ? "(#{indx.to_s.rjust(3)}) " : ""
        str = "#{indexString}#{object['announce'].lines.first.strip}#{requirements}"
        if object['metric']>=2 then
            str = str.green
        end
        str
    end

    def self.putsObjects(objects, remaining_number_of_lines, indx)
        return remaining_number_of_lines if objects.size==0
        return remaining_number_of_lines if remaining_number_of_lines<=0
        object = objects.shift
        str = Jupiter::objectToStringLine(object, indx)
        puts str
        Jupiter::putsObjects(objects,remaining_number_of_lines-Jupiter::verticalSpace(str), indx+1)
    end

    def self.putshelp()
        puts "Special General Commands:"
        puts "    help"
        puts "    search <pattern>"
        puts "    on <requirement>"
        puts "    off <requirement> <number of hours>"
        puts "    show <requirement> # shows all the objects of that requirement"
        puts "    wave: <wave description>"
        puts "    stream: <stream description>"
        puts "    <object index>"
        puts "    <object index> command ; ..."
        puts "    lib # Invoques the Librarian interactive"
        puts ""
        puts "Special Object Commands:"
        puts "    expose # pring the object"
        puts "    require <requirement>"
        puts "    command ..."
        puts "    (+)datetimecode"
    end

    def self.editTextUsingTextmate(text)
      filename = SecureRandom.hex
      filepath = "/tmp/#{filename}"
      File.open(filepath, 'w') {|f| f.write(text)}  
      system("/usr/local/bin/mate \"#{filepath}\"")
      print "> press enter when done: "
      input = STDIN.gets
      IO.read(filepath)  
    end

    def self.processItemDescriptionPossiblyAsTextEditorInvitation(description)
        if description=='text' then
            editTextUsingTextmate("")
        else
            description
        end
    end

    def self.selectDisplayObjects()
        objects = CatalystCore::objects(6)
            .select{|object| object["metric"] > 0 }
            .select{ |object| RequirementsOperator::meetRequirements(object['uuid']) }
    end

    def self.main()
        loop {
            puts "# #{ "-" * (Jupiter::screenWidth()-3) }"
            if WaveDevOps::archivesGarbageCollection(true)>0 then
                LucilleCore::pressEnterToContinue()
                next
            end
            objects = Jupiter::selectDisplayObjects()
            screen_space = Jupiter::screenHeight()-6
            if objects.size>0 then
                screen_space = screen_space-Jupiter::verticalSpace(objects.first['announce']) 
            end
            screen_space = Jupiter::putsObjects(objects.clone, screen_space, 0)
            if objects.size>0 then
                puts ""
                screen_space = screen_space-1
            end
            flagIntermediaryInformation = false
            if ( unsatisfied_requirements = RequirementsOperator::currentlyUnsatisfifiedRequirements() ).size>0 then
                puts "REQUIREMENTS OFF: "+unsatisfied_requirements.join(", ").green
                screen_space = screen_space-1
                flagIntermediaryInformation = true
            end
            if flagIntermediaryInformation then
                puts ""
                screen_space = screen_space-1
            end
            if objects.size>0 then
                Jupiter::putsObjectWithShellDisplay(objects.first, objects.clone)
            else
                puts "Nothing to do (^_^). Sleeping for 60 seconds at #{Time.new.to_s}"
                sleep 60 
            end
        }
    end

    def self.datetimeSpecification2232ToDatetime(code)
        localsuffix = Time.new.to_s[-5,5]
        if code[0,1]=='+' then
            code = code[1,999]
            if code.index('@') then
                # The first part is an integer and the second HH:MM
                part1 = code[0,code.index('@')]
                part2 = code[code.index('@')+1,999]
                "#{( DateTime.now + part1.to_i ).to_date.to_s} #{part2}:00 #{localsuffix}"
            else
                if code.include?('days') or code.include?('day') then
                    if code.include?('days') then
                        # The entire string is to be interpreted as a number of days from now
                        "#{( DateTime.now + code[0,code.size-4].to_f ).to_time.to_s}"
                    else
                        # The entire string is to be interpreted as a number of days from now
                        "#{( DateTime.now + code[0,code.size-3].to_f ).to_time.to_s}"
                    end

                elsif code.include?('hours') or code.include?('hour') then
                    if code.include?('hours') then
                        ( Time.new + code[0,code.size-5].to_f*3600 ).to_s
                    else
                        ( Time.new + code[0,code.size-4].to_f*3600 ).to_s
                    end
                else
                    raise "error: Jupiter::datetimeSpecification2232ToDatetime 30c6e629-1d71-4777-aad5-de2a40662623"
                end
            end
        else
            # Here we expect "YYYY-MM-DD" or "YYYY-MM-DD@HH:MM" 
            if code.index('@') then
                part1 = code[0,10]
                part2 = code[11,999]
                "#{part1} #{part2}:00 #{localsuffix}"
            else
                part1 = code[0,10]
                part2 = code[11,999]
                "#{part1} 00:00:00 #{localsuffix}"
            end
        end
    end

end

LucilleCore::assert("PascalMiscUtils 1.0", Jupiter::datetimeSpecification2232ToDatetime("+0 days") == "#{DateTime.now.to_time.to_s}")
LucilleCore::assert("PascalMiscUtils 1.5", Jupiter::datetimeSpecification2232ToDatetime("+1.6 days") == "#{( DateTime.now + 1.6 ).to_time.to_s}")
LucilleCore::assert("PascalMiscUtils 1.6", Jupiter::datetimeSpecification2232ToDatetime("+0 hours") == "#{DateTime.now.to_time.to_s}")
LucilleCore::assert("PascalMiscUtils 1.5", Jupiter::datetimeSpecification2232ToDatetime("+0 day") == "#{DateTime.now.to_time.to_s}")
LucilleCore::assert("PascalMiscUtils 1.5", Jupiter::datetimeSpecification2232ToDatetime("+1.6 day") == "#{( DateTime.now + 1.6 ).to_time.to_s}")
LucilleCore::assert("PascalMiscUtils 1.6", Jupiter::datetimeSpecification2232ToDatetime("+0 hour") == "#{DateTime.now.to_time.to_s}")
LucilleCore::assert("PascalMiscUtils 1.7", Jupiter::datetimeSpecification2232ToDatetime("+1.6 hour") == "#{( Time.new + 1.6*3600 ).to_s}")
LucilleCore::assert("PascalMiscUtils 2.0", Jupiter::datetimeSpecification2232ToDatetime("+1@12:32") == "#{( DateTime.now + 1 ).to_date.to_s} 12:32:00 #{Time.new.to_s[-5,5]}")
LucilleCore::assert("PascalMiscUtils 3.0", Jupiter::datetimeSpecification2232ToDatetime("2017-06-19@12:32") == "2017-06-19 12:32:00 #{Time.new.to_s[-5,5]}")

# -----------------------------------------------------------------

RequirementsOperator::init()
DoNotShowUntil::init()

# -----------------------------------------------------------------

Thread.new { 
    sleep 60
    Jupiter::emailSyncOnSchedule(true)
    loop {
        sleep 1200
        Jupiter::emailSyncOnSchedule(false)
    }
}

Jupiter::main()

