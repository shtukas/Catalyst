#!/usr/bin/ruby

# encoding: UTF-8

require_relative "Libs/loader.rb"

# ----------------------------------------------------------------------------

def imports()
    LucilleCore::locationsAtFolder("/Users/pascal/Desktop/Nx50 Inbox").each{|location|
        #puts location
        Nx50s::importLocationAsNewAionPointNx50(location)
        LucilleCore::removeFileSystemLocation(location)
        sleep 1
    }

    system("#{File.dirname(__FILE__)}/../../vienna-import")

    Nx50s::maintenance()
end

Thread.new {
    loop {
        sleep 300
        imports()
    }
}

getItems = lambda {
    UIServices::ns16s()
}

processItems = lambda {|items|

    accessItem = lambda { |item| 
        return if item.nil? 
        return if item["access"].nil?
        item["access"].call()
    }

    system("clear")

    status = Anniversaries::dailyBriefingIfNotDoneToday()
    return "ns:loop" if status

    vspaceleft = Utils::screenHeight()-6

    puts ""

    items.each_with_index{|item, indx|
        indexStr   = "(#{"%3d" % indx})"
        announce   = "#{indexStr} #{item["announce"]}"
        break if ((indx > 0) and ((vspaceleft - Utils::verticalSize(announce)) < 0))
        puts announce
        vspaceleft = vspaceleft - Utils::verticalSize(announce)
    }

    puts "Nx50s #{CoreDataTx::getObjectsBySchema("Nx50").size} items".yellow

    puts "listing: new wave / ondate / calendar item / todo / work item / endless | ondates | anniversaries | calendar | waves | endlesss | work | work on/off | ns17s | exit".yellow
    if !items.empty? then
        puts "top    : .. (access top) | select / expose / start / done (<n>) | [] (Priority.txt) | <datecode> | done".yellow
    end

    command = LucilleCore::askQuestionAnswerAsString("> ")

    return "ns:loop" if command == ""

    if (unixtime = Utils::codeToUnixtimeOrNull(command.gsub(" ", ""))) then
        item = items[0]
        return "ns:loop" if item.nil? 
        DoNotShowUntil::setUnixtime(item["uuid"], unixtime)
        return "ns:loop"
    end

    # -- listing -----------------------------------------------------------------------------

    if Interpreting::match("..", command) then
        accessItem.call(items[0])
        return "ns:loop"
    end

    if (ordinal = Interpreting::readAsIntegerOrNull(command)) then
        accessItem.call(items[ordinal])
        return "ns:loop"
    end

    if Interpreting::match("select *", command) then
        _, ordinal = Interpreting::tokenizer(command)
        ordinal = ordinal.to_i
        accessItem.call(items[ordinal])
        return "ns:loop"
    end

    if Interpreting::match("expose *", command) then
        _, ordinal = Interpreting::tokenizer(command)
        ordinal = ordinal.to_i
        item = items[ordinal]
        return "ns:loop" if item.nil?
        puts JSON.pretty_generate(item)
        LucilleCore::pressEnterToContinue()
        return "ns:loop"
    end

    if Interpreting::match("access", command) then
        accessItem.call(items[0])
        return "ns:loop"
    end

    if Interpreting::match("start *", command) then
        _, ordinal = Interpreting::tokenizer(command)
        ordinal = ordinal.to_i
        accessItem.call(items[ordinal])
        return "ns:loop"
    end

    if Interpreting::match("done", command) then
        item = items[0]
        return "ns:loop" if item.nil? 
        return "ns:loop" if item["done"].nil?
        item["done"].call()
        return "ns:loop"
    end

    if Interpreting::match("done *", command) then
        _, ordinal = Interpreting::tokenizer(command)
        ordinal = ordinal.to_i
        item = items[ordinal]
        return "ns:loop" if item.nil?
        return "ns:loop" if item["done"].nil?
        item["done"].call()
        return "ns:loop"
    end

    if Interpreting::match("new endless", command) then
        Endless::interactivelyCreateNew()
        return "ns:loop"
    end

    if Interpreting::match("new ondate", command) then
        nx31 = Nx31s::interactivelyIssueNewOrNull()
        puts JSON.pretty_generate(nx31)
        return "ns:loop"
    end

    if Interpreting::match("new wave", command) then
        Waves::issueNewWaveInteractivelyOrNull()
        return "ns:loop"
    end

   if Interpreting::match("new todo", command) then
        nx50 = {}
        nx50["uuid"]        = SecureRandom.uuid
        nx50["schema"]      = "Nx50"
        nx50["unixtime"]    = Time.new.to_f

        coordinates = Nx102::interactivelyIssueNewCoordinates3OrNull()
        return nil if coordinates.nil?

        nx50["description"] = coordinates[0]
        nx50["contentType"] = coordinates[1]
        nx50["payload"]     = coordinates[2]

        CoreDataTx::commit(nx50)

        return "ns:loop"
    end

    if Interpreting::match("new work item", command) then
        Work::interactvelyIssueNewItem()
        return "ns:loop"
    end

    if Interpreting::match("new calendar item", command) then
        Calendar::interactivelyIssueNewCalendarItem()
        return "ns:loop"
    end

    if Interpreting::match("waves", command) then
        Waves::main()
        return "ns:loop"
    end

    if Interpreting::match("anniversaries", command) then
        Anniversaries::main()
        return "ns:loop"
    end

    if Interpreting::match("calendar", command) then
        Calendar::main()
        return "ns:loop"
    end

    if Interpreting::match("endlesss", command) then
        Endless::main()
        return "ns:loop"
    end

    if Interpreting::match("ondates", command) then
        Nx31s::main()
        return "ns:loop"
    end

    if Interpreting::match("work", command) then
        Work::main()
        return "ns:loop"
    end

    if Interpreting::match("work on", command) then
        KeyValueStore::set(nil, "0daf738e-b46d-4e3c-932c-4eef58bb0467:#{Utils::today()}", "on")
    end

    if Interpreting::match("work off", command) then
        KeyValueStore::set(nil, "0daf738e-b46d-4e3c-932c-4eef58bb0467:#{Utils::today()}", "off")
    end

    if Interpreting::match("ns17s", command) then
        [Endless::ns17sTexts(), Nx50s::ns17text(), Work::ns17text(), Waves::ns17sLowPriorityText()]
            .flatten
            .sort
            .each{|str| puts "    #{str }"}
        LucilleCore::pressEnterToContinue()
    end



    # -- top -----------------------------------------------------------------------------

    if Interpreting::match("[]", command) then
        item = items[0]
        next if item.nil? 
        next if item["[]"].nil?
        item["[]"].call()
        return "ns:loop"
    end

    if Interpreting::match("exit", command) then
        return "ns:exit"
    end

    "ns:loop"
}

UIServices::programmableListingDisplay(getItems, processItems)
