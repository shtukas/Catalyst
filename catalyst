#!/usr/bin/ruby

# encoding: UTF-8

require 'json'

require 'date'

require 'colorize'

require 'securerandom'
# SecureRandom.hex    #=> "eb693ec8252cd630102fd0d0fb7c3485"
# SecureRandom.hex(4) #=> "eb693123"
# SecureRandom.uuid   #=> "2d931510-d99f-494a-8c67-87feb05e1594"

require "/Galaxy/LucilleOS/Misc-Resources/Ruby-Libraries/LucilleCore.rb"

require 'fileutils'
# FileUtils.mkpath '/a/b/c'
# FileUtils.cp(src, dst)
# FileUtils.mv 'oldname', 'newname'
# FileUtils.rm(path_to_image)
# FileUtils.rm_rf('dir/to/remove')

require_relative "CatalystCore.rb"

require_relative "Wave-Emails.rb"

require "/Galaxy/LucilleOS/Misc-Resources/Ruby-Libraries/xstore.rb"
=begin

    Xcache::set(key, value)
    Xcache::getOrNull(key)
    Xcache::getOrDefaultValue(key, defaultValue)
    Xcache::destroy(key)

    XcacheSets::values(setuid)
    XcacheSets::insert(setuid, valueuid, value) # value can be an object
    XcacheSets::remove(setuid, valueuid)

    XStore::set(repositorypath, key, value)
    XStore::getOrNull(repositorypath, key)
    XStore::getOrDefaultValue(repositorypath, key, defaultValue)
    XStore::destroy(repositorypath, key)

    XStoreSets::values(repositorypath, setuid)
    XStoreSets::insert(repositorypath, setuid, valueuid, value) # value can be an object
    XStoreSets::remove(repositorypath, setuid, valueuid)

    Xcache and XStore have identical interfaces
    Xcache is XStore with a repositorypath defaulting to x-space

=end

# ----------------------------------------------------------------------------

CATALYST_DROPOFF_FOLDERPATH = "/Galaxy/DataBank/Catalyst/Wave-DropOff"
NINJA_DROPOFF_FOLDERPATH = "/Galaxy/DataBank/Catalyst/Ninja-DropOff"
NINJA_ITEMS_REPOSITORY_FOLDERPATH = "/Galaxy/DataBank/Ninja/Items"

def email_sync_on_schedule(verbose)
    if LucilleCore::trueNoMoreOftenThanNEverySeconds("29a504de-7985-493b-b809-332357bda3a7", 1200) then
        begin
            newEmailCount = GeneralEmailClient::syncEmailDataWithServer(JSON.parse(IO.read("/Galaxy/DataBank/Catalyst/Wave-Email-Config/guardian-relay.json")), verbose)
            if newEmailCount>0 then
                puts "Retrieved #{newEmailCount} new emails"
            end
            OperatorEmailDownloader::syncEmailDataWithServer(JSON.parse(IO.read("/Galaxy/DataBank/Catalyst/Wave-Email-Config/operator.json")), verbose)
            # We call again so that the clock restarts at the end of the process
            LucilleCore::trueNoMoreOftenThanNEverySecondsReset("29a504de-7985-493b-b809-332357bda3a7")
        rescue
        end
    end    
end

def screen_height()
    `/usr/bin/env tput lines`.to_i
end

def screen_width()
    `/usr/bin/env tput cols`.to_i
end

def vertical_space(announce)
    announce.lines.map{|line| (line.size/screen_width())+1 }.inject(0, :+)
end

def tokenIsInteger(token)
    token == token.to_i.to_s
end

def puts_object_shell_display(object, dislayobjects, preListObjects)

    # Here is the reason why the second argument was introduced
    # A first display is performed. 
    # You select number 8.
    # The list of objects is recomputed and the 8th (actually the 9th) one is selected.
    # There is no guaranty that the one selected was the one you were looking at since the objects
    # could have been reordered between the two computations.

    # Here:
    # If you select an ordinal, you get to apply it to the list you were looking at when you made that 
    # mental selection.

    requirements = $requirement_operator.getObjectRequirements(object['uuid']).join(", ")
    requirements = requirements.size>0 ? " ( #{requirements} )".green : ''

    puts "#{object['announce'].strip}#{requirements}"

    object['default-commands'] = [] if object['default-commands'].nil?

    puts [
        object['default-commands'].join(" ").green ,
        object['commands'].join(" ").red
    ].select{|s| s.size>0 }.join(" ; ").strip

    print "---> "

    expression = STDIN.gets().strip

    if expression=="push" then
        $pending_list_uuids << object['uuid']
        return
    end

    if expression.start_with?('insert') then
        description = expression[6,expression.size].strip
        uuid = SecureRandom.hex(4)
        schedule = WaveSchedules::makeScheduleObjectInteractivelyOrNull()
        folderpath = WaveTimelineUtils::timestring22ToFolderpath(LucilleCore::timeStringL22())
        FileUtils.mkpath folderpath
        File.open("#{folderpath}/catalyst-uuid", 'w') {|f| f.write(uuid) }
        File.open("#{folderpath}/catalyst-description.txt", 'w') {|f| f.write(description) }
        WaveTimelineUtils::writeScheduleToDisk(uuid, schedule)
        return
    end

    if expression.start_with?("search") then
        pattern = expression[6,expression.size].strip
        searchobjects = CatalystCore::objects()
            .select{|object| object['announce'].downcase.include?(pattern.downcase) }
        if searchobjects.size>0 then
            searchobject = LucilleCore::interactivelySelectEntityFromListOfEntitiesOrNull("object: ", searchobjects, lambda{ |item| item['announce'] })
            if searchobject then
                puts_object_shell_display(searchobject, dislayobjects, preListObjects)
            end
        end
        return
    end

    if expression.start_with?("require") then
        requirement = expression[7,expression.size].strip
        $requirement_operator.addObjectRequirement(object['uuid'],requirement)
        return
    end

    if expression.start_with?("on") then
        requirement = expression[2,expression.size].strip
        $requirement_operator.setRequirementOn(requirement)
        return
    end

    if expression.start_with?("off") then
        requirement = expression[3,expression.size].strip
        $requirement_operator.setRequirementOff(requirement)
        return
    end

    # ---------------------
    # default commands

    if expression.size==0 and object['default-commands'] then
        object['default-commands'].each{|command|
            if command.start_with?('shell:') then
                command = command[7,command.size].strip
                system(command)
            else
                object['command-interpreter'].call(object, command)
            end
        }
        return
    end

    # ---------------------
    # regular expression: optional integer and commands

    def expression_decomposition(expression, dislayobjects, preListObjects)
        tokens = 
            if expression.start_with?('+') then
                [expression]
            else
                expression.split(' ').map{|t| t.strip }
            end
        if tokenIsInteger(tokens[0]) then
            indx = tokens[0].to_i
            targetObject = indx<100 ? dislayobjects.drop(indx).first : preListObjects.drop(indx-100).first 
            tokens.shift
            [targetObject, tokens]
        else
            [nil, tokens]
        end
    end

    targetObject, tokens = expression_decomposition(expression, dislayobjects.clone, preListObjects.clone)

    if targetObject and tokens.size==0 then
        $pending_list_uuids.delete(targetObject['uuid'])
        puts_object_shell_display(targetObject, dislayobjects, preListObjects)
    end

    if targetObject and tokens.size>0 then
        $pending_list_uuids.delete(targetObject['uuid'])
        tokens.each{|command|
            targetObject['command-interpreter'].call(targetObject, command)
        }
    end    

    if targetObject.nil? and tokens.size==0 then
        # Nothing to do 
    end

    if targetObject.nil? and tokens.size>0 then
        tokens.each{|command|
            object['command-interpreter'].call(object, command)
        }        
    end
end

def puts_objects(objects, remaining_number_of_lines, indx)
    return remaining_number_of_lines if objects.size==0
    return remaining_number_of_lines if remaining_number_of_lines<=0
    object = objects.shift
    requirements = $requirement_operator.getObjectRequirements(object['uuid']).join(", ")
    requirements = requirements.size>0 ? " ( #{requirements} )".green : ''
    indexString = "(#{indx.to_s.rjust(3)})"
    str = "#{indexString} #{object['announce']}#{requirements}"
    if object['metric']>=2 then
        str = str.green
    end
    if indx>=100 then
        str = str.yellow
    end
    puts str
    puts_objects(objects,remaining_number_of_lines-vertical_space(object['announce']), indx+1)
end

class DropOff
    # DropOff::collectWaveObjects()
    def self.collectWaveObjects()
        Dir.entries(CATALYST_DROPOFF_FOLDERPATH)
            .select{|filename| filename[0, 1] != '.' }
            .map{|filename| "#{CATALYST_DROPOFF_FOLDERPATH}/#{filename}" }
            .each{|sourcelocation|
                uuid = SecureRandom.hex(4)
                description = 
                    if sourcelocation[-4,4] == '.txt' and IO.read(sourcelocation).lines.to_a.size == 1 then
                        IO.read(sourcelocation).strip
                    else
                        File.basename(sourcelocation)
                    end
                schedule = WaveSchedules::makeScheduleObjectNew()
                folderpath = WaveTimelineUtils::timestring22ToFolderpath(LucilleCore::timeStringL22())
                FileUtils.mkpath folderpath
                File.open("#{folderpath}/catalyst-uuid", 'w') {|f| f.write(uuid) }
                File.open("#{folderpath}/catalyst-description.txt", 'w') {|f| f.write(description) }
                WaveTimelineUtils::writeScheduleToDisk(uuid,schedule)
                if File.file?(sourcelocation) then
                    FileUtils.cp(sourcelocation,folderpath)
                else
                    FileUtils.cp_r(sourcelocation,folderpath)
                end
                File.open("#{folderpath}/wave-target-filename.txt", 'w') {|f| f.write(File.basename(sourcelocation)) }
                LucilleCore::removeFileSystemLocation(sourcelocation)
            }
    end
    # DropOff::collectNinjaObjects()
    def self.collectNinjaObjects()
        Dir.entries(NINJA_DROPOFF_FOLDERPATH)
            .select{|filename| filename[0, 1] != '.' }
            .map{|filename| "#{NINJA_DROPOFF_FOLDERPATH}/#{filename}" }
            .each{|sourcelocation|
                folderpath = "#{NINJA_ITEMS_REPOSITORY_FOLDERPATH}/#{Time.new.strftime("%Y")}/#{Time.new.strftime("%Y%m")}/#{Time.new.strftime("%Y%m%d")}/#{Time.new.strftime("%Y%m%d-%H%M%S-%6N")}-ninja"
                FileUtils.mkpath(folderpath)
                if File.file?(sourcelocation) then
                    FileUtils.cp(sourcelocation,folderpath)
                else
                    FileUtils.cp_r(sourcelocation,folderpath)
                end
                LucilleCore::removeFileSystemLocation(sourcelocation)
            }
    end
end

class RequirementsOperator

    def initialize()
        @data = nil
        @pathToDataFile = "/Galaxy/DataBank/Catalyst/requirements-structure/requirements-structure.json"
        self.loadDataFromDisk()
    end

    def loadDataFromDisk()
        @data = JSON.parse(IO.read(@pathToDataFile))
        if @data['requirements-status'].nil? then
            @data['requirements-status'] = {}
        end
    end

    def saveDataToDisk()
        File.open(@pathToDataFile,'w') {|f| f.puts(JSON.pretty_generate(@data)) }
    end

    def getObjectRequirements(uuid)
        @data['items-requirements-distribution'][uuid] || []
    end

    def requirementIsCurrentlySatisfied(requirement)
        @data['requirements-status']["#{requirement}"].nil? or @data['requirements-status']["#{requirement}"]
    end

    def meetRequirements(uuid)
        self.getObjectRequirements(uuid)
            .all?{|requirement| self.requirementIsCurrentlySatisfied(requirement) }
    end

    def addObjectRequirement(uuid,requirement)
        requirements = @data['items-requirements-distribution'][uuid] || []
        requirements << requirement
        requirements = requirements.uniq.sort
        @data['items-requirements-distribution'][uuid] = requirements
        self.saveDataToDisk()
    end

    def setRequirementOn(requirement)
        @data['requirements-status']["#{requirement}"] = true
        self.saveDataToDisk()
    end

    def setRequirementOff(requirement)
        @data['requirements-status']["#{requirement}"] = false
        self.saveDataToDisk()
    end

    def allRequirements()
        @data['items-requirements-distribution'].values.flatten.uniq
    end

    def currentlyUnsatisfifiedRequirements()
        self.allRequirements().select{|requirement| !self.requirementIsCurrentlySatisfied(requirement) }
    end

end

# -----------------------------------------------------------------

$requirement_operator = RequirementsOperator.new()
$pending_list_uuids = []

email_sync_on_schedule(true)

Thread.new { 
    loop {
        sleep 1200
        email_sync_on_schedule(false)
    }
}

firstrun = true

loop {
    
    TodaySectionManagement::performSync()
    DropOff::collectWaveObjects()
    DropOff::collectNinjaObjects()

    objects = CatalystCore::objects()
        .select{ |object| $requirement_operator.meetRequirements(object['uuid']) }
        .first(screen_height()-5)

    puts "# #{ "-" * (screen_width()-3) }".yellow

    count = WaveDevOps::archivesGarbageCollection(true)
    if count>0 then
        LucilleCore::pressEnterToContinue()
        next
    end

    screen_space = screen_height()-7

    if firstrun then
        puts "Special General Commands:".green
        puts "    insert <wave item description>".green
        puts "    search <pattern>".green
        puts "    on <requirement>".green
        puts "    off <requirement>".green
        puts ""
        puts "Special Object Commands:".green
        puts "    require <requirement>".green
        puts "    push".green
        puts ""
        firstrun = false
        screen_space = screen_space-9
    end

    unsatisfied_requirements = $requirement_operator.currentlyUnsatisfifiedRequirements()
    if unsatisfied_requirements.size>0 then
        puts "REQUIREMENTS OFF: "+unsatisfied_requirements.join(", ").green
        puts ""
        screen_space = screen_space-2
    end

    preListObjects = objects.select{|object| ( object['metric'] > 0 ) and $pending_list_uuids.include?(object['uuid']) }
    screen_space = puts_objects(
        preListObjects.clone, 
        screen_space, 
        100
    )
    puts "" if preListObjects.size>0


    mainListObjects = objects.select{|object| ( object['metric'] > 0 ) and !$pending_list_uuids.include?(object['uuid']) }

    screen_space = screen_space-vertical_space(mainListObjects.first['announce']) if mainListObjects.size>0

    screen_space = puts_objects(
        mainListObjects.clone, 
        screen_space, 
        0
    )

    puts ""

    if mainListObjects.size>0 then
        puts_object_shell_display(mainListObjects.first, mainListObjects.clone, preListObjects.clone)
    elsif 
        preListObjects.size>0
        puts "Nothing to do (^_^). Defaulting to prelisting:"
        puts_object_shell_display(preListObjects.first, preListObjects.clone, preListObjects.clone)        
    else
        puts "Nothing to do (^_^). Sleeping for 60 seconds at #{Time.new.to_s}"
        sleep 60
    end

}

