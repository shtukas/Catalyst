#!/usr/bin/ruby

# encoding: UTF-8
require 'json'
require 'date'
require 'colorize'
require 'securerandom'
# SecureRandom.hex    #=> "eb693ec8252cd630102fd0d0fb7c3485"
# SecureRandom.hex(4) #=> "eb693123"
# SecureRandom.uuid   #=> "2d931510-d99f-494a-8c67-87feb05e1594"
require 'fileutils'
# FileUtils.mkpath '/a/b/c'
# FileUtils.cp(src, dst)
# FileUtils.mv 'oldname', 'newname'
# FileUtils.rm(path_to_image)
# FileUtils.rm_rf('dir/to/remove')
require 'digest/sha1'
# Digest::SHA1.hexdigest 'foo'
# Digest::SHA1.file(myFile).hexdigest
require 'find'
require 'drb/drb'
require 'thread'

require "/Galaxy/Software/Misc-Common/Ruby-Libraries/LucilleCore.rb"

require "/Galaxy/Software/Misc-Common/Ruby-Libraries/KeyValueStore.rb"
=begin
    KeyValueStore::set(repositorylocation or nil, key, value)
    KeyValueStore::getOrNull(repositorylocation or nil, key)
    KeyValueStore::getOrDefaultValue(repositorylocation or nil, key, defaultValue)
    KeyValueStore::destroy(repositorylocation or nil, key)
=end

# -----------------------------------------------------------------

require_relative "NSXMiscLibraries/NSXConstants.rb"
require_relative "NSXMiscLibraries/NSXBob.rb"
require_relative "NSXMiscLibraries/NSXCatalystObjectsOperator.rb"
require_relative "NSXMiscLibraries/NSXData.rb"
require_relative "NSXMiscLibraries/NSXDisplayUtils.rb"
require_relative "NSXMiscLibraries/NSXGeneralCommandHandler.rb"
require_relative "NSXMiscLibraries/NSXGenericContents.rb"
require_relative "NSXMiscLibraries/NSXDoNotShowUntilDatetime.rb"
require_relative "NSXMiscLibraries/NSXCatalystDevOps.rb"
require_relative "NSXMiscLibraries/NSXEmailClients.rb"
require_relative "NSXMiscLibraries/NSXFolderProbe.rb"
require_relative "NSXMiscLibraries/NSXLightThreadUtils.rb"
require_relative "NSXMiscLibraries/NSXMiscUtils.rb"
require_relative "NSXMiscLibraries/NSXRunner.rb"
require_relative "NSXMiscLibraries/NSXStreamsUtils.rb"
require_relative "NSXMiscLibraries/NSXStringParser.rb"
require_relative "NSXMiscLibraries/NSXSpots.rb"

require_relative "NSXAgents/NSXAgentBabyNights.rb"
require_relative "NSXAgents/NSXAgentTodayNotes.rb"
require_relative "NSXAgents/NSXAgentHouse.rb"
require_relative "NSXAgents/NSXAgentLightThread.rb"
require_relative "NSXAgents/NSXAgentNinja.rb"
require_relative "NSXAgents/NSXAgentStreams.rb"
require_relative "NSXAgents/NSXAgentVienna.rb"
require_relative "NSXAgents/NSXAgentWave.rb"

# -------------------------------------------------------------------------

CATALYST_CODE_FOLDERPATH = File.dirname(__FILE__) 
CATALYST_INBOX_DROPOFF_FOLDERPATH = "/Users/pascal/Desktop/Catalyst-Inbox"

class CatalystDevOps

    # CatalystDevOps::collectInboxPackage()
    def self.collectInboxPackage()
        Dir.entries(CATALYST_INBOX_DROPOFF_FOLDERPATH)
            .select{|filename| filename[0, 1] != '.' }
            .map{|filename| "#{CATALYST_INBOX_DROPOFF_FOLDERPATH}/#{filename}" }
            .each{|sourcelocation|
                genericItem = NSXGenericContents::issueItemLocationMoveOriginal(sourcelocation)
                NSXStreamsUtils::issueItemAtNextOrdinalUsingGenericContentsItem("03b79978bcf7a712953c5543a9df9047", genericItem) # Inbox
            }
    end

    # CatalystDevOps::locationHashRecursively(location)
    def self.locationHashRecursively(location)
        if File.file?(location) then
            Digest::SHA1.hexdigest("#{location}:#{Digest::SHA1.file(location).hexdigest}")
        else
            trace = Dir.entries(location)
                .reject{|filename| filename.start_with?(".") }
                .map{|filename| "#{location}/#{filename}" }
                .map{|location| CatalystDevOps::locationHashRecursively(location) }
                .join("::")
            Digest::SHA1.hexdigest(trace)
        end
    end

end

class CatalystUI

    # CatalystUI::FromEmailPartDecodedToShouldDisplay(contents)
    def self.FromEmailPartDecodedToShouldDisplay(contents)
        return false if contents.include?("Seen on [PROD]")
        return false if contents.include?("PRbuilds results")
        return false if (contents.include?("Merged") and contents.include?("into master."))
        true
    end

    # CatalystUI::stringOrFirstString(content_type)
    def self.stringOrFirstString(content_type)
        if content_type.class.to_s == "String" then
            content_type
        else
            content_type.first
        end
    end

    # CatalystUI::displayableEmailParts(mail)
    def self.displayableEmailParts(mail)
        if mail.multipart? then
            mail.parts.to_a.select{|part| CatalystUI::stringOrFirstString(part.content_type).start_with?("text/plain") }
        else
            [ mail.body ]
        end
    end

    # CatalystUI::specialNS0928EmailDisplay(object)
    def self.specialNS0928EmailDisplay(object)
        system("clear")
        puts object["announce"]
        emailFilename = object["data"]["generic-contents-item"]["email-filename"]
        filepath = NSXGenericContents::resolveFilenameToFilepathOrNull(emailFilename)
        mail = Mail.read(filepath)
        CatalystUI::displayableEmailParts(mail).each{|part|
            contents = part.decoded
            next if !CatalystUI::FromEmailPartDecodedToShouldDisplay(contents)
            puts ""
            puts "-- begin -----------------------------------------------"
            puts contents
            puts "--- end ------------------------------------------------"
            puts ""
            print "Type 'open' to open the email or nothing to discard: "
            answer = STDIN.gets().strip
            if answer == "open" then
                NSXGeneralCommandHandler::processCommand(object, "open")
            end
        }
    end

    # CatalystUI::objectShouldTriggerOnScreenNotification(object)
    def self.objectShouldTriggerOnScreenNotification(object)
        object["agentuid"] == "d2de3f8e-6cf2-46f6-b122-58b60b2a96f1" and object["data"]["stream-item"]["streamuuid"] == "03b79978bcf7a712953c5543a9df9047"
    end

    # CatalystUI::removeObjectFromCollection(displayObjects, objectuuid)
    def self.removeObjectFromCollection(displayObjects, objectuuid)
        displayObjects.reject{|object| object["uuid"]==objectuuid }
    end

    # CatalystUI::objectIsEmailSpecialCircumstances1(object)
    def self.objectIsEmailSpecialCircumstances1(object)
        return false if object.nil?
        return true if object["announce"].include?("notifications@github.com")
        return true if object["announce"].include?("noreply@github.com")
        false
    end

    # CatalystUI::objectIsDoneOnEmptyCommand(object)
    def self.objectIsDoneOnEmptyCommand(object)
        return false if object.nil?
        if object and
            object["agentuid"] == "d2de3f8e-6cf2-46f6-b122-58b60b2a96f1" and
            object["data"]["generic-contents-item"] and
            object["data"]["generic-contents-item"]["email-subject"] and
            object["data"]["generic-contents-item"]["email-subject"].start_with?("Declined:") then
            return true
        end
        if object and
            object["agentuid"] == "d2de3f8e-6cf2-46f6-b122-58b60b2a96f1" and
            object["data"]["generic-contents-item"] and
            object["data"]["generic-contents-item"]["email-subject"] and
            object["data"]["generic-contents-item"]["email-subject"].start_with?("Cancelled event: Editorial Tools Demo") then
            return true
        end
        if object and
            object["agentuid"] == "d2de3f8e-6cf2-46f6-b122-58b60b2a96f1" and
            object["announce"].include?('notifications@github.com') then
            return true
        end
        if object and
            object["agentuid"] == "d2de3f8e-6cf2-46f6-b122-58b60b2a96f1" and
            object["announce"].include?('no-reply@sns.amazonaws.com') and object["announce"].include?('frontend-PROD-security-groups-update') then
            return true
        end
        if object and
            object["agentuid"] == "d2de3f8e-6cf2-46f6-b122-58b60b2a96f1" and
            object["announce"].include?('Fastly Maintenance - Capacity Expansion') then
            return true
        end
        false
    end

    # CatalystUI::cardinalForTakingAllTheRunnings(objects, cardinal = 0)
    def self.cardinalForTakingAllTheRunnings(objects, cardinal = 0)
        objects = objects.clone
        if objects.any?{|object| object["isRunning"] } then
            CatalystUI::cardinalForTakingAllTheRunnings(objects[1, objects.size], cardinal+1)
        else
            cardinal
        end
    end

    # CatalystUI::performPrimaryDisplayWithCatalystObjects(displayObjects)
    def self.performPrimaryDisplayWithCatalystObjects(displayObjects)

        system("clear")

        spotnames = NSXSpots::getSpotNames()
        if spotnames.size>0 then
            puts "Awaiting: #{spotnames.join(", ")}".yellow
        end

        if displayObjects.size==0 then
            puts "No objects found"
            print "--> "
            command = STDIN.gets().strip
            NSXGeneralCommandHandler::processCommand(nil, command)
            return
        end

        differential = ( NSXStreamsUtils::getDifferentialOrNull() || -1 )
        if differential >= 0 then
            puts "Stream Differential [ -7: #{NSXStreamsUtils::getCardinalForDateOrNull(NSXMiscUtils::nDaysAgo(7))} , -1: #{NSXStreamsUtils::getCardinalForDateOrNull(NSXMiscUtils::nDaysAgo(1))} ] 0: #{NSXStreamsUtils::cardinal()} -> #{NSXStreamsUtils::getDifferentialOrNull()}".red
        end

        standardlp = NSXMiscUtils::getStandardListingPosition()
        focusobject = nil

        displayObjects
            .first([CatalystUI::cardinalForTakingAllTheRunnings(displayObjects), NSXMiscUtils::screenHeight()-7].max)
            .each_with_index{|object, indx|
                position = indx+1
                if position == standardlp then
                    focusobject = object
                end 
                puts NSXDisplayUtils::objectToStringForCatalystListing(object, position, standardlp)
            }

        if focusobject.nil? and (standardlp>1) then
            NSXMiscUtils::setStandardListingPosition(1)
            return
        end

        if focusobject.nil? then
            puts "Nothing to do for the moment (^_^)"
        end

        # -----------------------------------------------------------------------------------
        # Special Processing

        if CatalystUI::objectIsEmailSpecialCircumstances1(focusobject) then
            CatalystUI::specialNS0928EmailDisplay(focusobject)
            Thread.new {
                NSXGeneralCommandHandler::processCommand(focusobject, "done")
            }
            CatalystUI::performPrimaryDisplayWithCatalystObjects(displayObjects.reject{|object| object["uuid"]==focusobject["uuid"] })
            return
        end

        # -----------------------------------------------------------------------------------

        print "--> "
        command = STDIN.gets().strip

        if command == "" and CatalystUI::objectIsDoneOnEmptyCommand(focusobject) then
            Thread.new {
                NSXGeneralCommandHandler::processCommand(focusobject, "done") 
            }           
            CatalystUI::performPrimaryDisplayWithCatalystObjects(displayObjects.reject{|object| object["uuid"]==focusobject["uuid"] })
            return
        end

        if command == "done" then
            NSXGeneralCommandHandler::processCommand(focusobject, "done")
            CatalystUI::performPrimaryDisplayWithCatalystObjects(displayObjects.reject{|object| object["uuid"]==focusobject["uuid"] })
            return
        end

        if command.start_with?("'") then
            position = command[1,9].strip.to_i
            return if position==0
            return if position > displayObjects.size-1
            object = displayObjects[position-1]
            NSXDisplayUtils::doPresentObjectInviteAndExecuteCommand(object)
            return
        end

        NSXGeneralCommandHandler::processCommand(focusobject, command)
    end

    # CatalystUI::standardUILoop()
    def self.standardUILoop()
        loop {
            if STARTING_CODE_HASH != CatalystDevOps::locationHashRecursively(CATALYST_CODE_FOLDERPATH) then
                puts "Code change detected. Exiting."
                return
            end
            CatalystDevOps::collectInboxPackage()
            displayObjects = NSXCatalystObjectsOperator::catalystObjectsForMainListing()
            CatalystUI::performPrimaryDisplayWithCatalystObjects(displayObjects)
        }
    end

end

# -------------------------------------------------------------------------
# nslog

# -------------------------------------------------------------------------

STARTING_CODE_HASH = CatalystDevOps::locationHashRecursively(CATALYST_CODE_FOLDERPATH)

NSXStreamsUtils::sendOrphanStreamItemsToInbox()

# Make sure that each folder in /Galaxy/LightThreads has a LightThread for it

Dir.entries("/Galaxy/LightThreads")
    .reject{|filename| filename[0, 1] == "." }
    .reject{|filename| filename.start_with?("Icon") }
    .map{|filename| "/Galaxy/LightThreads/#{filename}" }
    .select{|filepath| NSXLightThreadUtils::lightThreads().none?{|lightThread| lightThread["folderpaths"].include?(filepath) } }
    .each{|filepath|
        puts "I could not find a LightThread for #{filepath}"
        lightThread = NSXLightThreadUtils::interactivelySelectLightThreadOrNull()
        next if lightThread.nil?
        lightThread["folderpaths"] << filepath
        NSXLightThreadUtils::commitLightThreadToDisk(lightThread)
    }

# Catalyst Interruption Screen Notification.

Thread.new {
    loop {
        sleep 130
        if NSXCatalystObjectsOperator::catalystObjectsForMainListing().any?{|object| CatalystUI::objectShouldTriggerOnScreenNotification(object) } then
            NSXMiscUtils::onScreenNotification("Catalyst", "Interruption")
        end
    }
}

# Archives Timeline Garbage Connection

Thread.new {
    return if !NSXMiscUtils::isLucille18()
    loop {
        sleep 140 
        if NSXMiscUtils::trueNoMoreOftenThanNEverySeconds(nil, "17e6377e-0ee6-4e38-80cf-40f40ca9cae9", 86400) then
            NSXCatalystDevOps::archivesTimelineGarbageCollection(false)
        end
    }
}

# Email Sync

Thread.new {
    return if !NSXMiscUtils::isLucille18()
    sleep 30
    loop {
        NSXMiscUtils::emailSync(false)
        sleep 1200
    }
}

$LightThreadTheBigUglyMemoryCache = {} # Map[LightThread, State]
# State: { "TheReferenceOne", "TheMovingOne", "CachedObjects" }

def resetLightThreadCache(lightThreadUUID)
    $LightThreadTheBigUglyMemoryCache[lightThreadUUID]["TheMovingOne"] = SecureRandom.hex
end

# -------------------------------------------------------------------------

CatalystUI::standardUILoop()

