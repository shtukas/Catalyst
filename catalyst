#!/usr/bin/ruby

# encoding: UTF-8
require 'json'
require 'date'
require 'colorize'
require 'securerandom'
# SecureRandom.hex    #=> "eb693ec8252cd630102fd0d0fb7c3485"
# SecureRandom.hex(4) #=> "eb693123"
# SecureRandom.uuid   #=> "2d931510-d99f-494a-8c67-87feb05e1594"
require 'fileutils'
# FileUtils.mkpath '/a/b/c'
# FileUtils.cp(src, dst)
# FileUtils.mv 'oldname', 'newname'
# FileUtils.rm(path_to_image)
# FileUtils.rm_rf('dir/to/remove')
require 'digest/sha1'
# Digest::SHA1.hexdigest 'foo'
# Digest::SHA1.file(myFile).hexdigest
require 'find'
require 'drb/drb'
require 'thread'

require "/Galaxy/Software/Misc-Common/Ruby-Libraries/Iphetra.rb"
=begin
    Iphetra::commitObjectToDisk(repositoryRootFolderPath, setuuid, object)
    Iphetra::getObjectByUUIDOrNull(repositoryRootFolderPath, setuuid, objectuuid)
    Iphetra::getObjects(repositoryRootFolderPath, setuuid)
=end

require "/Galaxy/Software/Misc-Common/Ruby-Libraries/LucilleCore.rb"

# -----------------------------------------------------------------

require_relative "NSXConstants.rb"

require_relative "NSXMiscLibraries/NSXDoNotShowUntilDatetime.rb"
require_relative "NSXMiscLibraries/NSXCatalystDevOps.rb"
require_relative "NSXMiscLibraries/NSXEmailClients.rb"
require_relative "NSXMiscLibraries/NSXFolderProbe.rb"
require_relative "NSXMiscLibraries/NSXLightThreadUtils.rb"
require_relative "NSXMiscLibraries/NSXMiscUtils.rb"
require_relative "NSXMiscLibraries/NSXStringParser.rb"

require_relative "NSXAgents/NSXAgentBabyNights.rb"
require_relative "NSXAgents/NSXAgentHouse.rb"
require_relative "NSXAgents/NSXAgentLightThread.rb"
require_relative "NSXAgents/NSXAgentNinja.rb"
require_relative "NSXAgents/NSXAgentVienna.rb"
require_relative "NSXAgents/NSXAgentWave.rb"
require_relative "NSXAgents/NSXAgentWIS.rb"

require_relative "NSXBob.rb"

require_relative "NSXDataOperator.rb"
require_relative "NSXDisplayOperator.rb"
require_relative "NSXGeneralCommandHandler.rb"

# -------------------------------------------------------------------------

class Timer
    def initialize(name)
        @name = name
        @times = []
        @startedTime = nil
    end
    def start()
        if @startedTime.nil? then
            @startedTime = Time.new.to_f
        else 
            raise "Trying to start an already started timer"
        end
    end
    def stop()
        if @startedTime.nil? then
            raise "Trying to stop a non started timer"
        else
            @times << Time.new.to_f - @startedTime
            @startedTime = nil
        end
    end
    def printTimes()
        puts "#{@name}: #{@times.join(", ")}"
    end
end

# -------------------------------------------------------------------------



# -------------------------------------------------------------------------
=begin

The Task system

A task is a lambda and a period in seconds

We put the tasks into an array and loop over that array. 
This ewnsure that only one task run at the same time, that there is enough pause between two task and
that we run the tasks roughtly as often as they should run.

=end

# Task(taskUniqueId, period, lambda, name, shouldCausePromptAndReload)

if NSXMiscUtils::isLucille18() then

    $THETASKS = []
    $THETASKS << [
        "49429DCB",
        86400,
        lambda {
             NSXCatalystDevOps::archivesTimelineGarbageCollection(false)
        },
        "NSXCatalystDevOps::archivesTimelineGarbageCollection(false)"
    ]
    $THETASKS << [
        "69429DCB",
        1200,
        lambda {
             NSXMiscUtils::emailSync(false)
        },
        "NSXMiscUtils::emailSync(false)"
    ]

    $THETASKSINDEX = 0
    $THETASKSSHEDULING = NSXSystemDataOperator::getOrDefaultValue("b0e73fa2-f035-4833-8945-b55f9463d87d", {})

    Thread.new {
        sleep 60
        loop {
            $THETASKSINDEX = ($THETASKSINDEX+1) % $THETASKS.size
            task = $THETASKS[$THETASKSINDEX]
            if Time.new.to_i - ( $THETASKSSHEDULING[task[0]] || 0 ) > task[1] then
                #puts "Task: #{task[3]}"
                task[2].call()
                $THETASKSSHEDULING[task[0]] = Time.new.to_i
                NSXSystemDataOperator::set("b0e73fa2-f035-4833-8945-b55f9463d87d", $THETASKSSHEDULING)
            end
            sleep 60
        }
    }

end

# -------------------------------------------------------------------------

NSXCatalystObjectsOperator::reloadObjectsFromAgents()

# -------------------------------------------------------------------------

Thread.new {
    loop {
        sleep 120
        Iphetra::resetInMemoryData()
        NSXCatalystObjectsOperator::flushInMemoryObjects()
        NSXCatalystObjectsOperator::reloadObjectsFromAgents()
    }
}

# -------------------------------------------------------------------------

loop {

    displayScreenSizeReductionIndex = 6

    system("clear")

    puts NSXGeneralCommandHandler::specialObjectCommandsAsString().green

    lightThreadCompletion = 100

    numbers = NSXLightThreadUtils::lightThreads().map{|lightThread| NSXLightThreadMetrics::lightThreadToLivePercentageOverThePastNDays(lightThread, 7) }
    lightThreadCompletion = numbers.inject(0, :+).to_f/numbers.size
    puts "LightThread completion (7 days): #{lightThreadCompletion.round(2)} %"

    puts ""
    standardlp = NSXMiscUtils::getStandardListingPosition()
    focusobject = NSXDisplayOperator::printScreen(displayScreenSizeReductionIndex, standardlp, lightThreadCompletion>=90)

    if focusobject.nil? then
        puts "Nothing to do for the moment (^_^)"
    end

    puts ""
    print "--> "
    command = STDIN.gets().strip

    if command == "" then
        next
    end

    if ( command == "..") and focusobject and focusobject["default-expression"] then
        command = focusobject["default-expression"]
    end

    if command == ';;' then
        command = 'open; done'
    end

    NSXGeneralCommandHandler::processCommand(focusobject, command)

    if command=="open" and focusobject and focusobject["schedule"] and focusobject["schedule"][":wave-email:"] then
        if (command = LucilleCore::askQuestionAnswerAsString("Additional command? : ")).size>0 then
            NSXGeneralCommandHandler::processCommand(focusobject, command)
        end
    end

}

