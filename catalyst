#!/usr/bin/ruby

# encoding: UTF-8
require 'json'
require 'date'
require 'colorize'
require 'securerandom'
# SecureRandom.hex    #=> "eb693ec8252cd630102fd0d0fb7c3485"
# SecureRandom.hex(4) #=> "eb693123"
# SecureRandom.uuid   #=> "2d931510-d99f-494a-8c67-87feb05e1594"
require 'fileutils'
# FileUtils.mkpath '/a/b/c'
# FileUtils.cp(src, dst)
# FileUtils.mv 'oldname', 'newname'
# FileUtils.rm(path_to_image)
# FileUtils.rm_rf('dir/to/remove')
require 'digest/sha1'
# Digest::SHA1.hexdigest 'foo'
# Digest::SHA1.file(myFile).hexdigest
require 'find'
require 'drb/drb'
require 'thread'
require "/Galaxy/local-resources/Ruby-Libraries/LucilleCore.rb"
require_relative "catalyst.rb"
# -----------------------------------------------------------------

=begin

(DisplayState) {
    "nsx26:all-catalyst-objects-above-water"        => Array[CatalystObject],
    "nsx26:objects-already-processed"   => Array[CatalystObject],
    "nsx26:object-still-to-go"          => Array[CatalystObject],
    "nsx26:lines-to-display"            => Array[String],
    "nsx26:screen-left-height"          => 10,
    "nsx26:standard-listing-position"   => Int
    "nsx26:current-position-cursor"     => Int,
    "nsx26:should-stop-display-process" => Boolean
    "nsx26:focus-object"                => nil or object
}

=end

class TheUltimateDisplayOperator

    # TheUltimateDisplayOperator::makeGenesysDisplayState()
    def self.makeGenesysDisplayState(screenLeftHeight, standardlp) # : DisplayState
        objectsAboveWater = CommonsUtils::flockObjectsUpdatedForDisplay()
                                .select{ |object| object["metric"] >= 0.2 }
        listsObjectsUUIDs = ListsOperator::allListsCatalystItemsUUID()
        regularObjects, listsObjects = objectsAboveWater.partition {|object| !listsObjectsUUIDs.include?(object["uuid"]) }
        {
            "nsx26:all-catalyst-objects-above-water" => objectsAboveWater,
            "nsx26:objects-already-processed"        => [],
            "nsx26:object-still-to-go"               => regularObjects.select{ |object| object["metric"] >= 0.2 }.sort{|o1,o2| o1['metric']<=>o2['metric'] }.reverse,
            "nsx26:lines-to-display"                 => [],
            "nsx26:screen-left-height"               => screenLeftHeight,
            "nsx26:standard-listing-position"        => standardlp,
            "nsx26:current-position-cursor"          => 0,
            "nsx26:should-stop-display-process"      => false,
            "nsx26:focus-object"                     => nil
        }
    end

    # TheUltimateDisplayOperator::displayStateTransition(displayState: DisplayState) : DisplayState
    def self.displayStateTransition(displayState) # return: DisplayState

        displayState["nsx26:current-position-cursor"] = displayState["nsx26:current-position-cursor"]+1
        displayState["nsx26:lines-to-display"] = []

        object = displayState["nsx26:object-still-to-go"].shift

        # --------------------------------------------------------------------------------
        if Bob::agentuuid2AgentData(object["agent-uid"]).nil? then
            EventsManager::commitEventToTimeline(EventsMaker::destroyCatalystObject(object["uuid"]))
            TheFlock::removeObjectIdentifiedByUUID(object["uuid"])
            return nil
        end

        # --------------------------------------------------------------------------------
        # Sometimes a wave item that is an email, gets deleted by the EmailClients process.
        # In such a case they are still in Flock and should not be showed
        if object["agent-uid"]=="283d34dd-c871-4a55-8610-31e7c762fb0d" then
            if object["schedule"][":wave-email:"] then
                if !File.exists?(object["item-data"]["folderpath"]) then
                    CatalystInterfaceUtils::executeCommandAgainstObject(object, "done", 1)
                    return TheUltimateDisplayOperator::displayStateTransition(displayState)
                end
            end
        end

        displayState["nsx26:objects-already-processed"] << object
        displayState["nsx26:lines-to-display"] << CatalystInterfaceUtils::objectToLineMainListingLambdaWithColour(object, displayState["nsx26:current-position-cursor"], displayState["nsx26:standard-listing-position"])
        displayState["nsx26:screen-left-height"] = displayState["nsx26:screen-left-height"] - 1 

        if displayState["nsx26:current-position-cursor"] == displayState["nsx26:standard-listing-position"] then
            displayState["nsx26:focus-object"] = object
            displayState["nsx26:lines-to-display"] << (" "*14)+CatalystInterfaceUtils::objectInferfaceString(object)
            displayState["nsx26:screen-left-height"] = displayState["nsx26:screen-left-height"] - 1 
        end

        if object["agent-uid"] == "201cac75-9ecc-4cac-8ca1-2643e962a6c6" then
            # We have a lisa object
            displayState["nsx26:object-still-to-go"] = displayState["nsx26:object-still-to-go"]
                .map{|o| 
                    o["metric"] = o["metric"]-0.01 
                    o
                }
            loop {
                lisa = object["item-data"]["lisa"]
                break if lisa["target"].nil?
                break if lisa["target"][0]!="list"
                listuuid = lisa["target"][1]
                list = ListsOperator::getListByUUIDOrNull(listuuid)
                break if list.nil?
                break if list["catalyst-object-uuids"].size==0
                ienum = LucilleCore::integerEnumerator() 
                displayState["nsx26:all-catalyst-objects-above-water"]
                    .select{|o| list["catalyst-object-uuids"].include?(o["uuid"]) }   
                    .sort{|o1,o2| o1["uuid"]<=>o2["uuid"] }
                    .map{|o|
                        o["metric"] = object["metric"] - 0.01*Math.exp(-ienum.next()) 
                        o[":is-lisa-listing-7fdfb1be:"] = true # This is an unofficial marker for objects which have been positioned as followers of the first lisa.
                        o
                    }
                    .each{|o|
                        displayState["nsx26:object-still-to-go"].unshift(o)
                    }
                break
            }

        end

        if displayState["nsx26:screen-left-height"] <= 0 then
            displayState["nsx26:should-stop-display-process"] = true
        end

        if displayState["nsx26:object-still-to-go"].count == 0 then
            displayState["nsx26:should-stop-display-process"] = true
        end

        displayState
    end
end

class CatalystInterfaceUtils

    # CatalystInterfaceUtils::objectInferfaceString(object)
    def self.objectInferfaceString(object)
        announce = object['announce'].strip
        defaultExpressionAsString = object["default-expression"] ? object["default-expression"] : ""
        requirements = RequirementsOperator::getObjectRequirements(object['uuid'])
        requirementsAsString = requirements.size>0 ? " ( #{requirements.join(" ")} )" : ''
        listIng = ListsOperator::getListsForCatalystObjectUUID(object["uuid"]).size > 0 ? " [list: #{ListsOperator::getListsForCatalystObjectUUID(object["uuid"]).map{|list| list["description"] }}]" : ""
        part2 = 
            [
                "#{requirementsAsString.green}",
                listIng,
                " (#{object["commands"].join(" ").red})",
                " \"#{defaultExpressionAsString.green}\""
            ].join()
        part2        
    end

    def self.object2Line_v1(object)
        announce = object['announce'].strip
        defaultExpressionAsString = object["default-expression"] ? object["default-expression"] : ""
        requirements = RequirementsOperator::getObjectRequirements(object['uuid'])
        requirementsAsString = requirements.size>0 ? " ( #{requirements.join(" ")} )" : ''
        listIng = ListsOperator::getListsForCatalystObjectUUID(object["uuid"]).size > 0 ? " [list: #{ListsOperator::getListsForCatalystObjectUUID(object["uuid"]).map{|list| list["description"] }}]" : ""
        part1 = 
            [
                "(#{"%.3f" % object["metric"]})",
                " [#{object["uuid"]}]",
                " #{announce}",
            ].join()
        if object["is-running"] then
            part1 = part1.green
        end
        part2 = CatalystInterfaceUtils::objectInferfaceString(object)
        part1 + part2
    end

    def self.positionOfLastRunningItemOrZero(objects)
        return 0 if objects.none?{ |object| object["is-running"] }
        while !objects.last["is-running"] do
            objects.pop
        end
        objects.size
    end

    def self.displayObject(object, standardlp)
        if standardlp then
            puts "[  #{"%2d" % standardlp}] #{CatalystInterfaceUtils::object2Line_v1(object)}"
        else
            puts CatalystInterfaceUtils::object2Line_v1(object)
        end
    end

    def self.positionDisplay(standardlp, position)
        if standardlp and position and standardlp==position then
            "[* #{"%2d" % position}]"
        else
            if position then
                "[  #{"%2d" % position}]"
            else
                "[]"
            end
        end
    end

    def self.objectToLineMainListing(object, position, standardlp)
        if position == standardlp then
            "#{CatalystInterfaceUtils::positionDisplay(standardlp, position)} #{CommonsUtils::object2Line_v0(object)}"
        else
            "#{CatalystInterfaceUtils::positionDisplay(standardlp, position)} #{CommonsUtils::object2Line_v0(object)[0,CommonsUtils::screenWidth()-9]}"
        end
    end

    def self.objectToLineMainListingLambdaWithColour(object, position, standardlp)
        str = CatalystInterfaceUtils::objectToLineMainListing(object, position, standardlp)
        if object["metric"]>1 then
            str = str.yellow
        end
        if position == standardlp then
            str = str.colorize(:background => :light_blue)
        end
        if object["is-running"] then
            str = str.green
        end
        str
    end

    def self.executeCommandAgainstObject(object, command, standardlp)
        # The reason why we have this function and processObjectAndCommand as separate function is that they have different signatures
        # That having been said, it is true that this function could just rewrite the object and/or the command.
        if command == "." then
            return
        end
        if command == "+" then
            CommonsUtils::setStandardListingPosition(CommonsUtils::getStandardListingPosition()+1)
            return
        end
        if command.start_with?(":") then
            if CommonsUtils::isInteger(command[1, command.size]) then
                position = command[1, command.size].to_i
                CommonsUtils::setStandardListingPosition([position, 0].max)
                return
            end
            return
        end
        command = command.size>0 ? command : ( object["default-expression"] ? object["default-expression"] : "" )
        CommonsUtils::processObjectAndCommand(object, command)
    end

    def self.doDisplayObjectAndPromptAndReturnCommand(object, standardlp)
        CatalystInterfaceUtils::displayObject(object, standardlp)
        print "--> "
        command = STDIN.gets().strip
        command
    end

    def self.displayLoop(codehash)
        loop {

            if codehash != CommonsUtils::codeHash() then
                puts "Source code hash changed. Exiting!"
                exit
            end

            displayScreenSizeReductionIndex = 6

            # Indicates over staying off requirement.
            if ( Time.new.to_i > FKVStore::getOrDefaultValue("e138267d-2aff-4a34-99bf-e396e0ddb6cb", "0").to_i ) then
                if RequirementsOperator::getCurrentlyUnsatisfiedRequirements().size>0 then
                    puts "REQUIREMENTS OFF: #{RequirementsOperator::getCurrentlyUnsatisfiedRequirements().join(", ")}"
                    LucilleCore::pressEnterToContinue()
                end
                FKVStore::set("e138267d-2aff-4a34-99bf-e396e0ddb6cb", Time.new.to_i + Random::rand*3600*2)
                next
            end

            # Ensure that every list has a lisa that drives it (list is a target of the lisa)
            lists = ListsOperator::getLists()
            lists.each{|list|
                lisas = LisaUtils::getLisasByTargetListUUID(list["list-uuid"])
                if lisas.size==0 then
                    puts "list: #{list["description"]} doesn't have a lisa targetting it"
                    puts "Existing lisas: "
                    LisaUtils::lisasWithFilepaths()
                        .each{|pair|
                            lisa, _ = pair
                            puts "    #{LisaUtils::lisaToString_v1(lisa, 40, 50)}"
                        }
                    loop {
                        operation = LucilleCore::selectEntityFromListOfEntitiesOrNull("operation:", ["use existing lisa", "create new lisa", "destroy the list"])
                        next if operation.nil?
                        if operation == "use existing lisa" then
                            puts "using an existing one:"
                            lisa = LisaUtils::interactivelySelectLisaOrNull()
                            next if lisa.nil?
                            if lisa["target"] then
                                puts "The lisa you have chosen already have a target"
                                LucilleCore::pressEnterToContinue()
                            else
                                lisa["target"] = ["list", list["list-uuid"]]
                                lisafilepath = LisaUtils::getLisaFilepathFromLisaUUIDOrNull(lisa["uuid"])
                                LisaUtils::commitLisaToDisk(lisa, File.basename(lisafilepath))
                            end
                        end
                        if operation == "create new lisa" then
                            puts "creating one:"
                            description = "lisa for list '#{list["description"]}'"
                            timeCommitmentInHours = LucilleCore::askQuestionAnswerAsString("time commitment in hours: ").to_f
                            timeUnitInDays = LucilleCore::askQuestionAnswerAsString("time unit in days: ").to_f
                            timestructure = { "time-commitment-in-hours"=> timeCommitmentInHours.to_f, "time-unit-in-days" => timeUnitInDays.to_f }
                            repeat = LucilleCore::askQuestionAnswerAsBoolean("should repeat?: ")
                            target = ["list", list["list-uuid"]]
                            lisa = LisaUtils::spawnNewLisa(description, timestructure, repeat, target)
                            puts JSON.pretty_generate(lisa)
                            LucilleCore::pressEnterToContinue()
                        end
                        if operation == "destroy the list" then
                            ListsOperator::destroyList(list["list-uuid"])
                        end
                        break
                    }
                end
            }

            # Ensure that every lisa has a time commitment greater than 0
            LisaUtils::lisasWithFilepaths()
                .each{|pair|
                    lisa, filepath = pair
                    next if lisa["time-structure"]["time-commitment-in-hours"] > 0
                    puts "The following lisa has a time commitment equal to zero"
                    puts JSON.pretty_generate(lisa)
                    timeCommitmentInHours = LucilleCore::askQuestionAnswerAsString("time commitment in hours: ").to_f
                    timeUnitInDays = LucilleCore::askQuestionAnswerAsString("time unit in days: ").to_f
                    timestructure = { "time-commitment-in-hours"=> timeCommitmentInHours.to_f, "time-unit-in-days" => timeUnitInDays.to_f }
                    lisa["time-structure"] = timestructure
                    LisaUtils::commitLisaToDisk(lisa, File.basename(filepath))
                }

            system("clear")

            standardlp = CommonsUtils::getStandardListingPosition()

            averageDailyCommitmentInHours = LisaUtils::dailyCommitmentInHours()
            percentageDone = 100 * ( LisaUtils::currentCollectivelyDoneInHours().to_f/averageDailyCommitmentInHours )

            puts "Lisa: #{"%.2f" % averageDailyCommitmentInHours} hours today ( #{"%.2f" % percentageDone} % done )"

            puts ""

            if RequirementsOperator::getCurrentlyUnsatisfiedRequirements().size>0 then
                puts "REQUIREMENTS: OFF: #{RequirementsOperator::getCurrentlyUnsatisfiedRequirements().join(", ")}".yellow
            end

            focusobject = nil

            displayStateCloner = lambda { |displayState|
                newDisplayState = {}
                newDisplayState["nsx26:all-catalyst-objects-above-water"] = displayState["nsx26:all-catalyst-objects-above-water"].map{|o| o.clone }
                newDisplayState["nsx26:objects-already-processed"] = displayState["nsx26:objects-already-processed"].map{|o| o.clone }
                newDisplayState["nsx26:object-still-to-go"] = displayState["nsx26:object-still-to-go"].map{|o| o.clone }
                newDisplayState["nsx26:lines-to-display"] = displayState["nsx26:lines-to-display"].clone
                newDisplayState["nsx26:screen-left-height"] = displayState["nsx26:screen-left-height"]
                newDisplayState["nsx26:standard-listing-position"] = displayState["nsx26:standard-listing-position"]
                newDisplayState["nsx26:current-position-cursor"] = displayState["nsx26:current-position-cursor"]
                newDisplayState["nsx26:should-stop-display-process"] = displayState["nsx26:should-stop-display-process"]
                newDisplayState["nsx26:focus-object"] = displayState["nsx26:focus-object"] ? displayState["nsx26:focus-object"].clone : nil
                newDisplayState
            }

            displayStateToShowable = lambda { |displayState|
                newDisplayState = {}
                newDisplayState["nsx26:all-catalyst-objects-above-water"] = displayState["nsx26:all-catalyst-objects-above-water"].size
                newDisplayState["nsx26:objects-already-processed"] = displayState["nsx26:objects-already-processed"].size
                newDisplayState["nsx26:object-still-to-go"] = displayState["nsx26:object-still-to-go"].size
                newDisplayState["nsx26:lines-to-display"] = displayState["nsx26:lines-to-display"].clone
                newDisplayState["nsx26:screen-left-height"] = displayState["nsx26:screen-left-height"]
                newDisplayState["nsx26:standard-listing-position"] = displayState["nsx26:standard-listing-position"]
                newDisplayState["nsx26:current-position-cursor"] = displayState["nsx26:current-position-cursor"]
                newDisplayState["nsx26:should-stop-display-process"] = displayState["nsx26:should-stop-display-process"]
                newDisplayState["nsx26:focus-object"] = displayState["nsx26:focus-object"] ? displayState["nsx26:focus-object"].clone : nil
                newDisplayState
            }

            displayState = TheUltimateDisplayOperator::makeGenesysDisplayState(CommonsUtils::screenHeight()-displayScreenSizeReductionIndex, standardlp)
            loop {
                displayState["nsx26:lines-to-display"].each{|line|
                    puts line
                }
                #puts JSON.pretty_generate(displayStateToShowable.call(displayState))
                #LucilleCore::pressEnterToContinue()
                displayState = TheUltimateDisplayOperator::displayStateTransition(displayStateCloner.call(displayState))
                break if displayState.nil?
                #puts JSON.pretty_generate(displayStateToShowable.call(displayState))
                #LucilleCore::pressEnterToContinue()
                focusobject = displayState["nsx26:focus-object"].clone
                break if displayState["nsx26:should-stop-display-process"]
            }

            if focusobject.nil? then
                puts "Nothing to do for the moment (^_^)"
                puts "Sleeping for 60 seconds"
                sleep 60
                next
            end

            puts ""
            print "--> "
            command = STDIN.gets().strip

            if ( command == "")  and focusobject["default-expression"] then
                command = focusobject["default-expression"]
            end

            shouldRemoveUnixtimeMark = lambda{|object, command|
                return true if command == "done"
                return true if command.start_with?("+")
                return true if ( object["agent-uid"]=="201cac75-9ecc-4cac-8ca1-2643e962a6c6" and command == "add-time" ) # lisa
                return true if ( object["agent-uid"]=="201cac75-9ecc-4cac-8ca1-2643e962a6c6" and command == "stop" ) # lisa
                false
            }

            if shouldRemoveUnixtimeMark.call(focusobject, command) then
                CyclesOperator::removeUnixtimeMark(focusobject["uuid"])
            end

            CatalystInterfaceUtils::executeCommandAgainstObject(focusobject, command, standardlp)

            if focusobject and focusobject["schedule"] and focusobject["schedule"][":wave-email:"] and command=="open" then
                if (command = LucilleCore::askQuestionAnswerAsString("Additional command? : ")).size>0 then
                    CatalystInterfaceUtils::executeCommandAgainstObject(focusobject, command, nil)
                end
            end

        }
    end
end

codehash = CommonsUtils::codeHash()
FlockDiskIO::loadFromEventsTimeline()

Thread.new {
    loop {
        sleep 60 * ( 1 + rand )
        if CommonsUtils::isLucille18() and CommonsUtils::trueNoMoreOftenThanNEverySeconds(nil, "ddb51cb6-7fd7-4737-90af-2c6524449937", 86400) then
            CatalystDevOps::archivesTimelineGarbageCollection(false)
        end
    }
}

Thread.new {
    loop {
        sleep 60 * ( 1 + rand )
        if CommonsUtils::isLucille18() and CommonsUtils::trueNoMoreOftenThanNEverySeconds(nil, "4b896858-bc31-407b-9c8f-3e890b408c75", 86400) then
            CatalystDevOps::eventsTimelineGarbageCollection(false)
        end
    }
}

Thread.new {
    loop {
        sleep 60 * ( 1 + rand )
        if CommonsUtils::isLucille18() and CommonsUtils::trueNoMoreOftenThanNEverySeconds(nil, "73672434-e76a-4cfd-8404-168863e9b681", 3600) then
            CommonsUtils::emailSync(false)
        end
    }
}

Thread.new {
    loop {
        sleep 60 * ( 1 + rand )
        if CommonsUtils::trueNoMoreOftenThanNEverySeconds(nil, "0daa5393-d43f-4e4f-a9e0-9776a5c8ec46", 300) then
            FlockDiskIO::loadFromEventsTimeline()
        end
    }
}

Thread.new {
    loop {
        # Bob::generalFlockUpgrade, to send screen notifications on overdoing lisas.
        sleep 60 * ( 1 + rand )
        Bob::generalFlockUpgrade()
    }
}

CatalystInterfaceUtils::displayLoop(codehash)
