#!/usr/bin/ruby

# encoding: UTF-8

require 'json'

require 'date'

require 'colorize'

require 'securerandom'
# SecureRandom.hex    #=> "eb693ec8252cd630102fd0d0fb7c3485"
# SecureRandom.hex(4) #=> "eb693123"
# SecureRandom.uuid   #=> "2d931510-d99f-494a-8c67-87feb05e1594"

require 'fileutils'
# FileUtils.mkpath '/a/b/c'
# FileUtils.cp(src, dst)
# FileUtils.mv 'oldname', 'newname'
# FileUtils.rm(path_to_image)
# FileUtils.rm_rf('dir/to/remove')
require 'digest/sha1'
# Digest::SHA1.hexdigest 'foo'
# Digest::SHA1.file(myFile).hexdigest
require 'find'

require "/Galaxy/local-resources/Ruby-Libraries/LucilleCore.rb"
require "/Galaxy/LucilleOS/Librarian/Librarian-Exported-Functions.rb"

require_relative "Wave-Emails.rb"
require_relative "Commons.rb"

require_relative "Agent-GuardianTime.rb"
require_relative "Agent-Kimchee.rb"
require_relative "Agent-Ninja.rb"
require_relative "Agent-Projects.rb"
require_relative "Agent-Stream.rb"
require_relative "Agent-TimeCommitments.rb"
require_relative "Agent-Today.rb"
require_relative "Agent-Vienna.rb"
require_relative "Agent-Wave.rb"

# ----------------------------------------------------------------------

THREADS_PATH_TO_REPOSITORY = "#{CATALYST_COMMON_DATABANK_FOLDERPATH}/Threads"

# ----------------------------------------------------------------------

# ThreadOperator::threadFolderpaths()
# ThreadOperator::folderPath2ThreadObject(folderpath)
# ThreadOperator::threadNames()
# ThreadOperator::threadObjects()
# ThreadOperator::threadUUID2FolderpathOrNull(uuid)
# ThreadOperator::addCatalystObjectUUIDToThread(objectuuid, threaduuid)
# ThreadOperator::threadCatalystObjectUUIDs(threaduuid)
# ThreadOperator::allThreadsCatalystUUIDs()

class ThreadOperator
    def self.threadFolderpaths()
        Dir.entries(THREADS_PATH_TO_REPOSITORY)
            .sort
            .select{|filename| filename[0,1]!="." }
            .map{|filename| "#{THREADS_PATH_TO_REPOSITORY}/#{filename}" }
    end

    def self.folderPath2ThreadObject(folderpath)
        JSON.parse(IO.read("#{folderpath}/thread-object.json"))
    end

    def self.threadNames()
        ThreadOperator::threadFolderpaths()
            .map{|folderpath| ThreadOperator::folderPath2ThreadObject(folderpath)["thread-name"] }
    end

    def self.threadObjects()
        ThreadOperator::threadFolderpaths()
            .map{|folderpath| ThreadOperator::folderPath2ThreadObject(folderpath) }
    end

    def self.threadUUID2FolderpathOrNull(uuid)
        ThreadOperator::threadFolderpaths()
            .each{|folderpath|
                return folderpath if ThreadOperator::folderPath2ThreadObject(folderpath)["thread-uuid"]==uuid
            }
        nil
    end

    def self.addCatalystObjectUUIDToThread(objectuuid, threaduuid)
        folderpath = ThreadOperator::threadUUID2FolderpathOrNull(threaduuid)
        arrayFilepath = "#{folderpath}/thread-catalyst-uuids.json"
        array = JSON.parse(IO.read(arrayFilepath))
        array << objectuuid 
        array = array.uniq
        File.open(arrayFilepath, "w"){|f| f.puts(JSON.generate(array)) }
    end

    def self.threadCatalystObjectUUIDs(threaduuid)
        folderpath = ThreadOperator::threadUUID2FolderpathOrNull(threaduuid)
        JSON.parse(IO.read("#{folderpath}/thread-catalyst-uuids.json"))
    end

    def self.allThreadsCatalystUUIDs()
        ThreadOperator::threadFolderpaths()
            .map{|folderpath| JSON.parse(IO.read("#{folderpath}/thread-catalyst-uuids.json")) }
            .flatten
    end

    def self.createNewThreadWithName(threadname)
        foldername = LucilleCore::timeStringL22()
        folderpath = "#{THREADS_PATH_TO_REPOSITORY}/#{foldername}"
        FileUtils.mkpath folderpath
        FileUtils.mkpath "#{folderpath}/documents"
        File.open("#{folderpath}/thread-catalyst-uuids.json", "w"){|f| f.puts(JSON.generate([])) }
        FileUtils.touch("#{folderpath}/thread-text.txt")
        threadObject = {}
        threadObject["thread-uuid"] = SecureRandom.uuid
        threadObject["thread-name"] = threadname
        File.open("#{folderpath}/thread-object.json", "w"){|f| f.puts(JSON.pretty_generate(threadObject)) }
        threadObject
    end

    def self.transform()
        uuids = self.allThreadsCatalystUUIDs()
        $flock["objects"] = $flock["objects"].map{|object|
            if uuids.include?(object["uuid"]) then
                object["metric"] = 0
            end
            object
        }
    end

    def self.moveObjectUUIDToAThread(objectuuid)
        threadObjects = ThreadOperator::threadObjects()
        threadObject = LucilleCore::interactivelySelectEntityFromListOfEntitiesOrNull("threads", threadObjects, lambda{ |object| object["thread-name"] })
        if threadObject.nil? then
            if LucilleCore::interactivelyAskAYesNoQuestionResultAsBoolean("Would you like to create a new thread ? ") then
                threadname = LucilleCore::askQuestionAnswerAsString("thread name: ")
                threadObject = ThreadOperator::createNewThreadWithName(threadname)
            else
                return
            end
        end
        ThreadOperator::addCatalystObjectUUIDToThread(objectuuid, threadObject["thread-uuid"])
        threadObject
    end
end

# Mercury::putshelp()
# Mercury::fDoNotShowUntilDateTimeTransform()
# Mercury::isInteger(str)
# Mercury::emailSync(verbose)
# Mercury::screenHeight()
# Mercury::screenWidth()
# Mercury::editTextUsingTextmate(text)
# Mercury::processItemDescriptionPossiblyAsTextEditorInvitation(description)
# Mercury::object2Line_v0(object)
# Mercury::object2Line_v1(object)
# Mercury::interactiveDisplayObjectAndProcessCommand(object)
# Mercury::takeWorkspaceSizeOrUpToFirstNewObject(workspaceSize, previousObjects, allObjectsLeft, allObjectsSelected = [])
# Mercury::processObjectAndCommand(object, command)
# Mercury::main2()

class Mercury

    def self.putshelp()
        puts "Special General Commands (view)"
        puts "    help"
        puts "    top"
        puts "    search <pattern>"
        puts "    l:show"
        puts "    r:on <requirement>"
        puts "    r:off <requirement>"
        puts "    r:show [requirement] # optional parameter # shows all the objects of that requirement"
        puts "    >>  # threads"
        puts "    >>> # new thread"
        puts ""
        puts ""
        puts "Special General Commands (inserts)"
        puts "    wave: <description>"
        puts "    stream: <description>"
        puts "    project: <description>"
        puts ""
        puts "Special General Commands (special circumstances)"
        puts "    clear # clear the screen"
        puts "    interface # run the interface of a given agent"
        puts "    lib # Invoques the Librarian interactive"
        puts ""
        puts "Special Object Commands:"
        puts "    (+)datetimecode"
        puts "    expose # pretty print the object"
        puts "    > # send to a thread"
        puts "    !today"
        puts "    l:add"
        puts "    r:add <requirement>"
        puts "    r:remove <requirement>"
        puts "    command ..."
    end

    def self.fDoNotShowUntilDateTimeTransform()
        $flock["objects"] = $flock["objects"].map{|object|
            if !$flock["do-not-show-until-datetime-distribution"][object["uuid"]].nil? and (Time.new.to_s < $flock["do-not-show-until-datetime-distribution"][object["uuid"]]) and object["metric"]<=1 then
                # The second condition in case we start running an object that wasn't scheduled to be shown today (they can be found through search)
                object["do-not-show-until-datetime"] = $flock["do-not-show-until-datetime-distribution"][object["uuid"]]
                object["metric"] = 0
            end
            if object["agent-uid"]=="283d34dd-c871-4a55-8610-31e7c762fb0d" and object["schedule"]["do-not-show-until-datetime"] and (Time.new.to_s < object["schedule"]["do-not-show-until-datetime"]) and object["metric"]<=1 then
                # The second condition in case we start running an object that wasn't scheduled to be shown today (they can be found through search)
                object["do-not-show-until-datetime"] = object["schedule"]["do-not-show-until-datetime"]
                object["metric"] = 0
            end
            object
        }
    end

    def self.isInteger(str)
        str.to_i.to_s == str
    end

    def self.emailSync(verbose)
        begin
            newEmailCount = GeneralEmailClient::sync(JSON.parse(IO.read("#{CATALYST_COMMON_DATABANK_FOLDERPATH}/Agents-Data/Wave/Wave-Email-Config/guardian-relay.json")), verbose)
            if newEmailCount>0 then
                #puts "Retrieved #{newEmailCount} new emails"
            end
            OperatorEmailClient::download(JSON.parse(IO.read("#{CATALYST_COMMON_DATABANK_FOLDERPATH}/Agents-Data/Wave/Wave-Email-Config/operator.json")), verbose)
        rescue
        end
    end

    def self.screenHeight()
        `/usr/bin/env tput lines`.to_i
    end

    def self.screenWidth()
        `/usr/bin/env tput cols`.to_i
    end

    def self.editTextUsingTextmate(text)
      filename = SecureRandom.hex
      filepath = "/tmp/#{filename}"
      File.open(filepath, 'w') {|f| f.write(text)}
      system("/usr/local/bin/mate \"#{filepath}\"")
      print "> press enter when done: "
      input = STDIN.gets
      IO.read(filepath)
    end

    def self.processItemDescriptionPossiblyAsTextEditorInvitation(description)
        if description=='text' then
            editTextUsingTextmate("")
        else
            description
        end
    end

    def self.object2Line_v0(object)
        announce = object['announce'].lines.first.strip
        if object["metric"]>1 then
            announce = announce.green
        end
        doNotShowUntilAsString = object["do-not-show-until-datetime"] ? " (do not show until: #{object["do-not-show-until-datetime"]})" : ""
        [
            "(#{"%.3f" % object["metric"]})",
            " [#{object["uuid"]}]",
            " #{announce}",
            "#{doNotShowUntilAsString}",
        ].join()
    end

    def self.object2Line_v1(object)
        announce = object['announce'].strip
        if object["metric"]>1 then
            announce = announce.green
        end
        defaultExpressionAsString = object["default-expression"] ? object["default-expression"] : ""
        requirements = RequirementsOperator::getObjectRequirements(object['uuid'])
        requirementsAsString = requirements.size>0 ? " ( #{requirements.join(" ")} )" : ''
        doNotShowUntilAsString = object["do-not-show-until-datetime"] ? " (do not show until: #{object["do-not-show-until-datetime"]})" : ""
        [
            "(#{"%.3f" % object["metric"]})",
            " [#{object["uuid"]}]",
            " #{announce}",
            "#{requirementsAsString.green}",
            "#{doNotShowUntilAsString}",
            " (#{object["commands"].join(" ").red})",
            " \"#{defaultExpressionAsString.green}\""
        ].join()
    end

    def self.interactiveDisplayObjectAndProcessCommand(object)
        print Mercury::object2Line_v1(object) + " : "
        givenCommand = STDIN.gets().strip
        command = givenCommand.size>0 ? givenCommand : ( object["default-expression"] ? object["default-expression"] : "" )
        Mercury::processObjectAndCommand(object, command)
    end

    def self.processObjectAndCommand(object, expression)

        # no object needed

        if expression == 'help' then
            Mercury::putshelp()
            LucilleCore::pressEnterToContinue()
            return
        end

        if expression == 'clear' then
            system("clear")
            return
        end

        if expression == ">>" then
            threadObjects = ThreadOperator::threadObjects()
            threadObject = LucilleCore::interactivelySelectEntityFromListOfEntitiesOrNull("threads", threadObjects, lambda{ |object| object["thread-name"] })
            return if threadObject.nil?
            loop {
                puts JSON.pretty_generate(threadObject)
                menuOptions = ["open file", "visit folder", "objects"]
                menuChoice = LucilleCore::interactivelySelectEntityFromListOfEntitiesOrNull("menu", menuOptions)
                if menuChoice=="open file" then
                    folderpath = ThreadOperator::threadUUID2FolderpathOrNull(threadObject["thread-uuid"])
                    system("open '#{folderpath}/thread-text.txt'")
                    next
                end
                if menuChoice=="visit documents" then
                    folderpath = ThreadOperator::threadUUID2FolderpathOrNull(threadObject["thread-uuid"])
                    system("open '#{folderpath}/documents'")
                    next
                end
                if menuChoice=="objects" then
                    loop {
                        threaduuids = ThreadOperator::threadCatalystObjectUUIDs(threadObject["thread-uuid"])
                        objects = $flock["objects"]
                            .select{|object| threaduuids.include?(object["uuid"]) }
                            .sort{|o1,o2| o1['metric']<=>o2['metric'] }
                            .reverse
                        object = LucilleCore::interactivelySelectEntityFromListOfEntitiesOrNull("object:", objects, lambda{ |object| Mercury::object2Line_v0(object) })
                        break if object.nil?
                        puts Mercury::object2Line_v1(object)
                        print "--> "
                        givenCommand = STDIN.gets().strip
                        command = givenCommand.size>0 ? givenCommand : ( objectselected["default-expression"] ? objectselected["default-expression"] : "" )
                        Mercury::processObjectAndCommand(objectselected, command)
                    }
                    next
                end
                break
            }
            return
        end

        if expression == ">>>" then
            threadname = LucilleCore::askQuestionAnswerAsString("thread name: ")
            ThreadOperator::createNewThreadWithName(threadname)
            return
        end

        if expression == "interface" then
            LucilleCore::interactivelySelectEntityFromListOfEntitiesOrNull("agent", PrimaryOperator::agents(), lambda{ |agent| agent["agent-name"] })["interface"].call()
            return
        end

        if expression == 'info' then
            puts "CatalystDevOps::getArchiveTimelineSizeInMegaBytes(): #{CatalystDevOps::getArchiveTimelineSizeInMegaBytes()}".green
            puts "Todolists:".green
            puts "    Stream count : #{( count1 = Stream::getUUIDs().size )}".green
            puts "    Vienna count : #{(count3 = $viennaLinkFeeder.links().count)}".green
            puts "    Total        : #{(count1+count3)}".green
            puts "Requirements:".green
            puts "    On  : #{(RequirementsOperator::getAllRequirements() - RequirementsOperator::getCurrentlyUnsatisfiedRequirements()).join(", ")}".green
            puts "    Off : #{RequirementsOperator::getCurrentlyUnsatisfiedRequirements().join(", ")}".green
            LucilleCore::pressEnterToContinue()
            return
        end

        if expression == 'lib' then
            LibrarianExportedFunctions::librarianUserInterface_librarianInteractive()
            return
        end

        if expression.start_with?('wave:') then
            description = expression[5, expression.size].strip
            description = Mercury::processItemDescriptionPossiblyAsTextEditorInvitation(description)
            uuid = SecureRandom.hex(4)
            folderpath = Wave::timestring22ToFolderpath(LucilleCore::timeStringL22())
            FileUtils.mkpath folderpath
            File.open("#{folderpath}/catalyst-uuid", 'w') {|f| f.write(uuid) }
            File.open("#{folderpath}/description.txt", 'w') {|f| f.write(description) }
            print "Default schedule is today, would you like to make another one ? [yes/no] (default: no): "
            answer = STDIN.gets().strip 
            schedule = 
                if answer=="yes" then
                    WaveSchedules::makeScheduleObjectInteractivelyEnsureChoice()
                else
                    {
                        "uuid" => SecureRandom.hex,
                        "type" => "schedule-7da672d1-6e30-4af8-a641-e4760c3963e6",
                        "@"    => "today",
                        "unixtime" => Time.new.to_i
                    }
                end
            Wave::writeScheduleToDisk(uuid,schedule)
            if (datetimecode = LucilleCore::askQuestionAnswerAsString("datetime code ? (empty for none) : ")).size>0 then
                if (datetime = CommonsUtils::codeToDatetimeOrNull(datetimecode)) then
                    $flock["do-not-show-until-datetime-distribution"][uuid] = datetime
                    EventsManager::commitEventToTimeline(EventsMaker::doNotShowUntilDateTime(uuid, datetime))
                end
            end
            print "Move to a thread ? [yes/no] (default: no): "
            answer = STDIN.gets().strip 
            if answer=="yes" then
                ThreadOperator::moveObjectUUIDToAThread(uuid)
            end
            LucilleCore::pressEnterToContinue()
            return
        end

        if expression.start_with?('stream:') then
            description = expression[7, expression.size].strip
            description = Mercury::processItemDescriptionPossiblyAsTextEditorInvitation(description)
            folderpath = Stream::issueNewItemWithDescription(description)
            puts "created item: #{folderpath}"
            LucilleCore::pressEnterToContinue()
            return
        end

        if expression.start_with?('project:') then
            description = expression[13, expression.size].strip
            description = Mercury::processItemDescriptionPossiblyAsTextEditorInvitation(description)
            folderpath = Projects::issueNewItemWithDescription(description)
            puts "created item: #{folderpath}"
            LucilleCore::pressEnterToContinue()
            return
        end

        if expression.start_with?('swat:') then
            description = expression[5, expression.size].strip
            description = Mercury::processItemDescriptionPossiblyAsTextEditorInvitation(description)
            folderpath = SWAT::issueNewItemWithDescription(description)
            puts "created item: #{folderpath}"
            LucilleCore::pressEnterToContinue()
            return
        end

        if expression.start_with?("r:on") then
            command, requirement = expression.split(" ").map{|t| t.strip }
            RequirementsOperator::setSatisfifiedRequirement(requirement)
            return
        end

        if expression.start_with?("r:off") then
            command, requirement = expression.split(" ").map{|t| t.strip }
            RequirementsOperator::setUnsatisfiedRequirement(requirement)
            return
        end

        if expression.start_with?("r:show") then
            command, requirement = expression.split(" ").map{|t| t.strip }
            if requirement.nil? or requirement.size==0 then
                requirement = RequirementsOperator::selectRequirementFromExistingRequirementsOrNull()
            end
            loop {
                requirementObjects = $flock["objects"].select{ |object| RequirementsOperator::getObjectRequirements(object['uuid']).include?(requirement) }
                selectedobject = LucilleCore::interactivelySelectEntityFromListOfEntitiesOrNull("object", requirementObjects, lambda{ |object| Mercury::object2Line_v0(object) })
                break if selectedobject.nil?
                Mercury::interactiveDisplayObjectAndProcessCommand(selectedobject)
            }
            return
        end

        if expression.start_with?("search") then
            pattern = expression[6,expression.size].strip
            loop {
                searchobjects = $flock["objects"].select{|object| Mercury::object2Line_v0(object).downcase.include?(pattern.downcase) }
                break if searchobjects.size==0
                selectedobject = LucilleCore::interactivelySelectEntityFromListOfEntitiesOrNull("object", searchobjects, lambda{ |object| Mercury::object2Line_v0(object) })
                break if selectedobject.nil?
                Mercury::interactiveDisplayObjectAndProcessCommand(selectedobject)
            }
            return
        end

        return if object.nil?

        # object needed

        if expression == ">" then
            if object["agent-uid"] == "30ff0f4d-7420-432d-b75b-826a2a8bc7cf" then
                puts "You cannot add a project to a thread"
                LucilleCore::pressEnterToContinue()
                return
            end
            ThreadOperator::moveObjectUUIDToAThread(object["uuid"])
            return
        end

        if expression == '!today' then
            TodayOrNotToday::notToday(object["uuid"])
            return
        end

        if expression == 'expose' then
            puts JSON.pretty_generate(object)
            LucilleCore::pressEnterToContinue()
            return
        end

        if expression.start_with?('+') then
            code = expression
            if (datetime = CommonsUtils::codeToDatetimeOrNull(code)) then
                $flock["do-not-show-until-datetime-distribution"][object["uuid"]] = datetime
                EventsManager::commitEventToTimeline(EventsMaker::doNotShowUntilDateTime(object["uuid"], datetime))
            end
            return
        end

        if expression.start_with?("r:add") then
            command, requirement = expression.split(" ").map{|t| t.strip }
            RequirementsOperator::addRequirementToObject(object['uuid'],requirement)
            return
        end

        if expression.start_with?("r:remove") then
            command, requirement = expression.split(" ").map{|t| t.strip }
            RequirementsOperator::removeRequirementFromObject(object['uuid'],requirement)
            return
        end

        if expression.size > 0 then
            tokens = expression.split(" ").map{|t| t.strip }
            .each{|command|
                PrimaryOperator::agentuuid2AgentData(object["agent-uid"])["object-command-processor"].call(object, command)
            }
        else
            PrimaryOperator::agentuuid2AgentData(object["agent-uid"])["object-command-processor"].call(object, "")
        end
    end

    def self.main2(runId)
        workspaceSize = 1
        mainschedule = {}
        mainschedule["archives-gc"] = Time.new.to_i + Random::rand*86400
        mainschedule["events-gc"]   = Time.new.to_i + Random::rand*86400
        mainschedule["requirements-off-notification"] = Time.new.to_i + Random::rand*3600*2
        loop {
            PrimaryOperator::generalUpgrade()
            TodayOrNotToday::transform()
            RequirementsOperator::transform()
            Mercury::fDoNotShowUntilDateTimeTransform()
            ThreadOperator::transform()
            $flock["objects"] = $flock["objects"].sort{|o1,o2| o1['metric']<=>o2['metric'] }.reverse
            system("clear")
            puts "THREADS: #{ThreadOperator::threadNames().join(", ")}".yellow
            if RequirementsOperator::getCurrentlyUnsatisfiedRequirements().size>0 then
                puts "REQUIREMENTS: OFF: #{RequirementsOperator::getCurrentlyUnsatisfiedRequirements().join(", ")}".yellow
            end
            dayprogression = {
                "projects" => ( GenericTimeTracking::adaptedTimespanInSeconds(CATALYST_COMMON_PROJECTS_AGENT_METRIC_GENERIC_TIME_TRACKING_KEY).to_f/3600 ).to_f/3,
                "stream"   => ( GenericTimeTracking::adaptedTimespanInSeconds(CATALYST_COMMON_STREAM_AGENT_METRIC_GENERIC_TIME_TRACKING_KEY).to_f/3600 ).to_f/3
            }
            if dayprogression["projects"] >= 1 and dayprogression["stream"] >= 1 then
                puts "DAY PROGRESSION: Cleared for night".green
            else
                puts "DAY PROGRESSION: Projects: #{ (100*dayprogression["projects"]).to_i } % ; Stream: #{ (100*dayprogression["stream"]).to_i } %".red
            end
            if ( Time.new.to_i > mainschedule["archives-gc"] ) and CommonsUtils::isLucille18() then
                lines = CatalystDevOps::archivesTimelineGarbageCollection()
                puts "Archives timeline garbage collection: #{lines.size}"
                lines.each{|line|
                    puts "    - #{line}"
                }
                LucilleCore::pressEnterToContinue() if lines.size>0
                mainschedule["archives-gc"] = Time.new.to_i + Random::rand*86400
            end
            if ( Time.new.to_i > mainschedule["events-gc"] ) and CommonsUtils::isLucille18() then
                lines = CatalystDevOps::eventsTimelineGarbageCollection()
                puts "Events timeline garbage collection: #{lines.size}"
                lines.each{|line|
                    puts "    - #{line}"
                }
                LucilleCore::pressEnterToContinue() if lines.size>0
                mainschedule["events-gc"] = Time.new.to_i + Random::rand*86400
            end
            if ( Time.new.to_i > mainschedule["requirements-off-notification"] ) then
                if RequirementsOperator::getCurrentlyUnsatisfiedRequirements().size>0 then
                    puts "REQUIREMENTS OFF: #{RequirementsOperator::getCurrentlyUnsatisfiedRequirements().join(", ")}"
                    LucilleCore::pressEnterToContinue()
                end
                mainschedule["requirements-off-notification"] = Time.new.to_i + Random::rand*3600*2
                next
            end
            puts ""
            objectselected = $flock["objects"].take(workspaceSize).last.clone
            $flock["objects"].take(workspaceSize).each_with_index{|o, index|
                string =
                    if o["uuid"]==objectselected["uuid"] then
                        "#{"%2d" % (index+1)} [*] #{Mercury::object2Line_v1(o)}"
                    else
                        "#{"%2d" % (index+1)}     #{Mercury::object2Line_v0(o)}"
                    end
                puts string
            }
            print "--> "
            givenCommand = STDIN.gets().strip
            if givenCommand=="+" then
                workspaceSize = workspaceSize+1
                next
            end
            if givenCommand=="-" then
                workspaceSize = [workspaceSize-1, 1].max
                next
            end
            if Mercury::isInteger(givenCommand) then
                workspaceSize = [givenCommand.to_i, 1].max
                next
            end
            command = givenCommand.size>0 ? givenCommand : ( objectselected["default-expression"] ? objectselected["default-expression"] : "" )
            Mercury::processObjectAndCommand(objectselected, command)
            File.open("#{CATALYST_COMMON_DATABANK_FOLDERPATH}/run-identifier.data", "w") {|f| f.write(runId) }
        }
    end
end

# -----------------------------------------------------------------

runId = SecureRandom.hex

Thread.new {
    loop {
        sleep 300
        FlockLoader::loadFlockFromDisk()
    }
}

Thread.new {
    loop {
        if CommonsUtils::isActiveInstance(runId) then
            Mercury::emailSync(false)
        end
        sleep 1200
    }
}

Mercury::main2(runId)
