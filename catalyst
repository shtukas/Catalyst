#!/usr/bin/ruby

# encoding: UTF-8
require 'json'
require 'date'
require 'colorize'
require 'securerandom'
# SecureRandom.hex    #=> "eb693ec8252cd630102fd0d0fb7c3485"
# SecureRandom.hex(4) #=> "eb693123"
# SecureRandom.uuid   #=> "2d931510-d99f-494a-8c67-87feb05e1594"
require 'fileutils'
# FileUtils.mkpath '/a/b/c'
# FileUtils.cp(src, dst)
# FileUtils.mv 'oldname', 'newname'
# FileUtils.rm(path_to_image)
# FileUtils.rm_rf('dir/to/remove')
require 'digest/sha1'
# Digest::SHA1.hexdigest 'foo'
# Digest::SHA1.file(myFile).hexdigest
require 'find'
require 'drb/drb'
require 'thread'

require "/Galaxy/Software/Misc-Common/Ruby-Libraries/LucilleCore.rb"

require "/Galaxy/Software/Misc-Common/Ruby-Libraries/KeyValueStore.rb"
=begin
    KeyValueStore::set(repositorylocation or nil, key, value)
    KeyValueStore::getOrNull(repositorylocation or nil, key)
    KeyValueStore::getOrDefaultValue(repositorylocation or nil, key, defaultValue)
    KeyValueStore::destroy(repositorylocation or nil, key)
=end

# -----------------------------------------------------------------

require_relative "NSXMiscLibraries/NSXConstants.rb"
require_relative "NSXMiscLibraries/NSXBob.rb"
require_relative "NSXMiscLibraries/NSXCatalystObjectsOperator.rb"
require_relative "NSXMiscLibraries/NSXData.rb"
require_relative "NSXMiscLibraries/NSXDisplayUtils.rb"
require_relative "NSXMiscLibraries/NSXGeneralCommandHandler.rb"
require_relative "NSXMiscLibraries/NSXGenericContents.rb"
require_relative "NSXMiscLibraries/NSXDoNotShowUntilDatetime.rb"
require_relative "NSXMiscLibraries/NSXCatalystDevOps.rb"
require_relative "NSXMiscLibraries/NSXEmailClients.rb"
require_relative "NSXMiscLibraries/NSXFolderProbe.rb"
require_relative "NSXMiscLibraries/NSXLightThreadUtils.rb"
require_relative "NSXMiscLibraries/NSXMiscUtils.rb"
require_relative "NSXMiscLibraries/NSXRunner.rb"
require_relative "NSXMiscLibraries/NSXStreamsUtils.rb"
require_relative "NSXMiscLibraries/NSXStringParser.rb"

require_relative "NSXAgents/NSXAgentBabyNights.rb"
require_relative "NSXAgents/NSXAgentTodayNotes.rb"
require_relative "NSXAgents/NSXAgentHouse.rb"
require_relative "NSXAgents/NSXAgentLightThread.rb"
require_relative "NSXAgents/NSXAgentNinja.rb"
require_relative "NSXAgents/NSXAgentStreams.rb"
require_relative "NSXAgents/NSXAgentVienna.rb"
require_relative "NSXAgents/NSXAgentWave.rb"

# -------------------------------------------------------------------------
class CatalystUI

    # CatalystUI::FromEmailPartDecodedToShouldDisplay(contents)
    def self.FromEmailPartDecodedToShouldDisplay(contents)
        return false if contents.include?("Seen on [PROD]")
        return false if contents.include?("PRbuilds results")
        return false if (contents.include?("Merged") and contents.include?("into master."))
        true
    end

    # CatalystUI::stringOrFirstString(content_type)
    def self.stringOrFirstString(content_type)
        if content_type.class.to_s == "String" then
            content_type
        else
            content_type.first
        end
    end

    # CatalystUI::displayableEmailParts(mail)
    def self.displayableEmailParts(mail)
        if mail.multipart? then
            mail.parts.to_a.select{|part| CatalystUI::stringOrFirstString(part.content_type).start_with?("text/plain") }
        else
            [ mail.body ]
        end
    end

    # CatalystUI::specialNS0928EmailDisplay(object)
    def self.specialNS0928EmailDisplay(object)
        system("clear")
        puts object["announce"]
        emailFilename = object["data"]["generic-contents-item"]["email-filename"]
        filepath = NSXGenericContents::resolveFilenameToFilepathOrNull(emailFilename)
        mail = Mail.read(filepath)
        CatalystUI::displayableEmailParts(mail).each{|part|
            contents = part.decoded
            next if !CatalystUI::FromEmailPartDecodedToShouldDisplay(contents)
            puts ""
            puts "-- begin -----------------------------------------------"
            puts contents
            puts "--- end ------------------------------------------------"
            puts ""
            print "Type 'open' to open the email or nothing to discard: "
            answer = STDIN.gets().strip
            if answer == "open" then
                NSXGeneralCommandHandler::processCommand(object, "open")
            end
        }
    end

    # CatalystUI::objectIsInterruption(object)
    def self.objectIsInterruption(object)
        object["agent-uid"] == "d2de3f8e-6cf2-46f6-b122-58b60b2a96f1" and object["data"]["stream-item"]["streamuuid"] == "29be9b439c40a9e8fcd34b7818ba4153"
    end

    # CatalystUI::shouldDisplayObject(object)
    def self.shouldDisplayObject(object)
        if object["agent-uid"] == "201cac75-9ecc-4cac-8ca1-2643e962a6c6" and object["announce"].start_with?("LightThread: X-Interruption") then
            return false
        end
        if object["agent-uid"] == "201cac75-9ecc-4cac-8ca1-2643e962a6c6" and object["announce"].start_with?("LightThread: X-Must All Be Done Today") then
            return false
        end
        true
    end

    # CatalystUI::removeObjectFromCollection(displayObjects, objectuuid)
    def self.removeObjectFromCollection(displayObjects, objectuuid)
        displayObjects.reject{|object| object["uuid"]==objectuuid }
    end

    # CatalystUI::objectIsNS0928Email(object)
    def self.objectIsNS0928Email(object)
        return false if object.nil?
        return true if object["announce"].include?("notifications@github.com")
        return true if object["announce"].include?("noreply@github.com")
        false
    end

    # CatalystUI::objectIsAutoDone(object)
    def self.objectIsAutoDone(object)
        return false if object.nil?
        return true if object["announce"].include?("Delivery Status Notification (Failure)")
        if object and
            object["agent-uid"] == "d2de3f8e-6cf2-46f6-b122-58b60b2a96f1" and
            object["data"]["generic-contents-item"]["email-subject"] and
            object["data"]["generic-contents-item"]["email-subject"].start_with?("Declined:") then
            return true
        end
        false
    end

    # CatalystUI::objectCanBeDoneAsynchronously(object)
    def self.objectCanBeDoneAsynchronously(object)
        return false if object["agent-uid"] == "f7b21eb4-c249-4f0a-a1b0-d5d584c03316"
        true
    end

    # CatalystUI::listingDisplay(displayObjects, unixtime)
    def self.listingDisplay(displayObjects, unixtime = nil)

        return if displayObjects.size==0

        # Unixtime represents the time at which the top iteration started

        if unixtime and (Time.new.to_i-unixtime)>1200 then
            puts "Condition bdd8f90d: Escaping rendering loop"
            return
        end

        displayScreenSizeLeft = NSXMiscUtils::screenHeight() - 6

        system("clear")

        print "Agents: "
        puts NSXBob::agents().map{|agentdata| agentdata["agent-name"] }.join(", ")
        puts NSXGeneralCommandHandler::specialObjectCommandsAsString()

        lines = JSON.parse(KeyValueStore::getOrNull(nil, "440cc2da-be91-4ccd-8a2e-cb4e9d947119") || "[]")
        if lines.size>0 then
            puts ""
            puts lines.map{|line| "    -> #{line}".blue }.join("\n")
            displayScreenSizeLeft = displayScreenSizeLeft - (lines.size+1)
        end

        puts ""
        standardlp = NSXMiscUtils::getStandardListingPosition()
        focusobject = nil

        displayObjects    
            .select{|object| CatalystUI::shouldDisplayObject(object) }
            .each_with_index{|object, indx|
                position = indx+1
                next if displayScreenSizeLeft <= 0 
                if position == standardlp then
                    focusobject = object
                end 
                string =  NSXDisplayUtils::objectToStringForCatalystListing(object, position, standardlp)
                displayScreenSizeLeft = displayScreenSizeLeft - string.lines.to_a.count
                puts string
            }

        if focusobject.nil? and (standardlp>1) then
            NSXMiscUtils::setStandardListingPosition(1)
            return
        end

        if focusobject.nil? then
            puts "Nothing to do for the moment (^_^)"
        end

        # -----------------------------------------------------------------------------------
        # Special Processing

        if CatalystUI::objectIsAutoDone(focusobject) then
            NSXGeneralCommandHandler::processCommand(focusobject, "done")
            return
        end

        if CatalystUI::objectIsNS0928Email(focusobject) then
            CatalystUI::specialNS0928EmailDisplay(focusobject)
            NSXGeneralCommandHandler::processCommand(focusobject, "done")
            return
        end

        # -----------------------------------------------------------------------------------

        puts ""
        print "--> "
        command = STDIN.gets().strip

        if command == ".." and focusobject["default-expression"] then
            command = focusobject["default-expression"]
        end

        if command == "" then
            CatalystUI::listingDisplay(displayObjects, unixtime)
            return
        end

        if command == 'help' then
            NSXGeneralCommandHandler::putshelp()
            LucilleCore::pressEnterToContinue()
            CatalystUI::listingDisplay(displayObjects, unixtime)
            return
        end

        if command == "+" then
            NSXMiscUtils::setStandardListingPosition(NSXMiscUtils::getStandardListingPosition()+1)
            CatalystUI::listingDisplay(displayObjects, unixtime)
            return
        end

        if command == ',,' then
            Thread.new {
                NSXDoNotShowUntilDatetime::setDatetime(focusobject["uuid"], NSXMiscUtils::codeToDatetimeOrNull("+1 hour"))
            }
            CatalystUI::listingDisplay(CatalystUI::removeObjectFromCollection(displayObjects, focusobject["uuid"]), unixtime)
            return
        end

        if command == "done" then
            if CatalystUI::objectCanBeDoneAsynchronously(focusobject) then
                Thread.new {
                    NSXGeneralCommandHandler::processCommand(focusobject, "done")
                }
            else
                NSXGeneralCommandHandler::processCommand(focusobject, "done")
                return
            end
            CatalystUI::listingDisplay(CatalystUI::removeObjectFromCollection(displayObjects, focusobject["uuid"]), unixtime)
            return
        end

        if command == ";;" then
            NSXGeneralCommandHandler::processCommand(focusobject, "open")
            Thread.new {
                NSXGeneralCommandHandler::processCommand(focusobject, "done")
            }
            CatalystUI::listingDisplay(CatalystUI::removeObjectFromCollection(displayObjects, focusobject["uuid"]), unixtime)
            return
        end

        if command.start_with?(":") and NSXMiscUtils::isInteger(command[1, command.size]) then
            position = command[1, command.size].strip.to_i
            NSXMiscUtils::setStandardListingPosition([position, 0].max)
            CatalystUI::listingDisplay(displayObjects, unixtime)
            return
        end

        if command.start_with?('+') and (datetime = NSXMiscUtils::codeToDatetimeOrNull(command)) then
            puts "Pushing to #{datetime}"
            NSXDoNotShowUntilDatetime::setDatetime(focusobject["uuid"], datetime)
            CatalystUI::listingDisplay(CatalystUI::removeObjectFromCollection(displayObjects, focusobject["uuid"]), unixtime)
            return
        end

        NSXGeneralCommandHandler::processCommand(focusobject, command)
    end

    # CatalystUI::lightThreadsETALines()
    def self.lightThreadsETALines()
        dimensions = NSXLightThreadUtils::lightThreads().map{|lightThread| lightThread["description"].size }.max 
        NSXLightThreadUtils::lightThreads().map{|lightThread|
            (lambda {|lightThread|
                timespanInSeconds = NSXLightThreadMetrics::timeInSecondsTo100PercentOrNull(lightThread)
                return nil if timespanInSeconds.nil?
                return nil if timespanInSeconds == 0
                "#{lightThread["description"].ljust(dimensions)}: #{"%4.2f" % (timespanInSeconds.to_f/3600)} hours"            
            }).call(lightThread)
        }.compact
    end

end

# -------------------------------------------------------------------------
# nslog

# -------------------------------------------------------------------------

Thread.new {
    loop {
        sleep 130
        if NSXCatalystObjectsOperator::catalystObjectsForMainListing().any?{|object| CatalystUI::objectIsInterruption(object) } then
            NSXMiscUtils::onScreenNotification("Catalyst", "Interruption")
        end
    }
}

Thread.new {
    return if !NSXMiscUtils::isLucille18()
    loop {
        sleep 140 
        if NSXMiscUtils::trueNoMoreOftenThanNEverySeconds(nil, "17e6377e-0ee6-4e38-80cf-40f40ca9cae9", 86400) then
            NSXCatalystDevOps::archivesTimelineGarbageCollection(false)
        end
    }
}

Thread.new {
    return if !NSXMiscUtils::isLucille18()
    sleep 30
    loop {
        NSXMiscUtils::emailSync(false)
        sleep 1200
    }
}

Thread.new {
    loop {
        sleep 10
        lines = CatalystUI::lightThreadsETALines()
        KeyValueStore::set(nil, "440cc2da-be91-4ccd-8a2e-cb4e9d947119", JSON.generate(lines))
    }
}

# -------------------------------------------------------------------------

loop {
    WaveDevOps::collectWave()
    NSXStreamsUtils::pickUpXStreamDropOff()
    NSXLightThreadUtils::lightThreads()
        .each{|lightThread| 
            targetFolderpath = lightThread["targetFolderpath"]
            if targetFolderpath.nil? or !File.exists?(targetFolderpath) then
                targetFolderpath = LucilleCore::askQuestionAnswerAsString("I could not find a target folder for LightThread '#{lightThread["description"]}'. Target folderpath: ")
                lightThread["targetFolderpath"] = targetFolderpath
                NSXLightThreadUtils::commitLightThreadToDisk(lightThread)
            end
        }
    displayObjects = NSXCatalystObjectsOperator::catalystObjectsForMainListing()
    if displayObjects.size==0 then
        puts "Could not find any object with display. Sleeping for a minute and then will try again"
        sleep 60
        next
    end

    CatalystUI::listingDisplay(displayObjects, Time.new.to_i)
}

